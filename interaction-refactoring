diff --git a/gameSource/LivingLifePage.cpp b/gameSource/LivingLifePage.cpp
index 5d4f5f580..ffc7a77fb 100644
--- a/gameSource/LivingLifePage.cpp
+++ b/gameSource/LivingLifePage.cpp
@@ -23223,6 +23223,972 @@ static void freeSavedPath() {
         }
     }
 
+static void savePlayerPath( LiveObject *inObject );
+static void restoreSavedPath( LiveObject *inObject );
+static void freeSavedPath();
+
+
+void LivingLifePage::checkForCellHit( CellHitRecord& inRecord ) {
+    float worldMouseX, worldMouseY;
+
+    screenToWorld( lastScreenMouseX,
+            lastScreenMouseY,
+            &worldMouseX,
+            &worldMouseY );
+    inRecord.cellX = lrintf( ( worldMouseX ) / CELL_D );
+    inRecord.cellY = lrintf( ( worldMouseY ) / CELL_D );
+
+    inRecord.destID = 0;
+    inRecord.floorDestID = 0;
+    inRecord.destNumContained = 0;
+
+    int mapX = inRecord.mapX = inRecord.cellX - mMapOffsetX + mMapD / 2;
+    int mapY = inRecord.mapY = inRecord.cellY - mMapOffsetY + mMapD / 2;
+    if( mapY >= 0 && mapY < mMapD &&
+        mapX >= 0 && mapX < mMapD ) {
+
+        inRecord.destID = mMap[ mapY * mMapD + mapX ];
+        inRecord.floorDestID = mMapFloors[ mapY * mMapD + mapX ];
+        inRecord.destNumContained = mMapContainedStacks[ mapY * mMapD + mapX ].size();
+        }
+    }
+
+
+
+void LivingLifePage::checkForPersonHit( PersonHitRecord& inRecord ) {
+    float worldMouseX, worldMouseY;
+
+    screenToWorld( lastScreenMouseX,
+            lastScreenMouseY,
+            &worldMouseX,
+            &worldMouseY );
+
+    LiveObject *ourLiveObject = getOurLiveObject();
+
+    double minDistThatHits = 2.0;
+
+    int clickDestX = lrintf( ( worldMouseX ) / CELL_D );
+
+    int clickDestY = lrintf( ( worldMouseY ) / CELL_D );
+
+    float clickExtraX = worldMouseX - clickDestX * CELL_D;
+    float clickExtraY = worldMouseY - clickDestY * CELL_D;
+
+    inRecord.cellX = clickDestX;
+    inRecord.cellY = clickDestY;
+    inRecord.targetID = -1;
+
+    // need to check 3 around cell in all directions because
+    // of moving object offsets
+
+    // start in front row
+    // right to left
+    // (check things that are in front first
+    for( int y=clickDestY-3; y<=clickDestY+3; y++ ) {
+        float clickOffsetY = ( clickDestY  - y ) * CELL_D + clickExtraY;
+
+        // don't worry about p->hitOurPlacement when checking them
+        // next, people in this row
+        // recently dropped babies are in front and tested first
+        for( int d=0; d<2 ; d++ )
+        for( int x=clickDestX+1; x>=clickDestX-1 ; x-- ) {
+            float clickOffsetX = ( clickDestX  - x ) * CELL_D + clickExtraX;
+
+            for( int i=gameObjects.size()-1; i>=0 ; i-- ) {
+
+                LiveObject *o = gameObjects.getElement( i );
+
+                if( o == ourLiveObject ) {
+                    continue;
+                    }
+
+                if( o->outOfRange ) {
+                    // out of range, but this was their last known position
+                    // don't draw now
+                    continue;
+                    }
+
+                if( o->heldByAdultID != -1 ) {
+                    // held by someone else, don't draw now
+                    continue;
+                    }
+
+                if( d == 1 &&
+                    ( o->heldByDropOffset.x != 0 ||
+                      o->heldByDropOffset.y != 0 ) ) {
+                    // recently dropped baby, skip
+                    continue;
+                    }
+                else if( d == 0 &&
+                         o->heldByDropOffset.x == 0 &&
+                         o->heldByDropOffset.y == 0 ) {
+                    // not a recently-dropped baby, skip
+                    continue;
+                    }
+
+
+                double oX = o->xd;
+                double oY = o->yd;
+
+                if( o->currentSpeed != 0 && o->pathToDest != NULL ) {
+                    oX = o->currentPos.x;
+                    oY = o->currentPos.y;
+                    }
+
+
+                if( round( oX ) == x &&
+                    round( oY ) == y ) {
+
+                    // here!
+
+                    double personClickOffsetX = ( oX - x ) * CELL_D;
+                    double personClickOffsetY = ( oY - y ) * CELL_D;
+
+                    personClickOffsetX = clickOffsetX - personClickOffsetX;
+                    personClickOffsetY = clickOffsetY - personClickOffsetY;
+
+                    ObjectRecord *obj = getObject( o->displayID );
+
+                    int sp, cl, sl;
+
+                    double dist = getClosestObjectPart( 
+                        obj,
+                        &( o->clothing ),
+                        NULL,
+                        o->clothingContained,
+                        false,
+                        computeCurrentAge( o ),
+                        -1,
+                        o->holdingFlip,
+                        personClickOffsetX,
+                        personClickOffsetY,
+                        &sp, &cl, &sl );
+
+                    if( dist < minDistThatHits ) {
+                        inRecord.cellX = x;
+                        inRecord.cellY = y;
+                        inRecord.targetID = o->id;
+                        return;
+                        }
+                    }
+                }
+            }
+        }
+
+
+
+    // find closest person for them to hit
+
+    doublePair clickPos = { (double)clickDestX, (double)clickDestY };
+
+
+    double closeDistance = 4;
+
+    for( int i=gameObjects.size()-1; i>=0; i-- ) {
+
+        LiveObject *o = gameObjects.getElement( i );
+
+        if( o->id == ourID ) {
+            // don't consider ourself as a kill target
+            continue;
+            }
+
+        if( o->outOfRange ) {
+            // out of range, but this was their last known position
+            // don't draw now
+            continue;
+            }
+
+        if( o->heldByAdultID != -1 ) {
+            // held by someone else, can't click on them
+            continue;
+            }
+
+        if( o->heldByDropOffset.x != 0 ||
+            o->heldByDropOffset.y != 0 ) {
+            // recently dropped baby, skip
+            continue;
+            }
+
+
+        double oX = o->xd;
+        double oY = o->yd;
+
+        if( o->currentSpeed != 0 && o->pathToDest != NULL ) {
+            oX = o->currentPos.x;
+            oY = o->currentPos.y;
+            }
+
+        doublePair oPos = { oX, oY };
+
+
+        double thisDistance = distance( clickPos, oPos );
+
+        if( thisDistance < closeDistance ) {
+            closeDistance = thisDistance;
+            inRecord.cellX = lrintf( oX );
+            inRecord.cellY = lrintf( oY );
+            inRecord.targetID = o->id;
+            }
+        }
+    }
+
+
+
+void LivingLifePage::hintForObjectInteraction( int holdingID, int destID ) {
+      if( holdingID > 0 ) {
+          TransRecord *tr = getTrans( holdingID, destID );
+
+          if( tr == NULL ) {
+              // try defaul transition
+              // tr = getTrans( -2, destID );
+
+              // for now, DO NOT consider default transition
+              // no main transition for this held object applies
+              // so we should probably give a hint about what CAN apply
+              // to the target object.
+
+              // Default transitions are currently just used to make
+              // something react to the player (usually for animals getting
+              // startled), not to actually accomplish
+              // something
+
+              // so we should show hints about the target object BEFORE it
+              // went into its (temporary) reaction state.
+              }
+
+          if( tr == NULL || tr->newTarget == destID ) {
+              // give hint about dest object which will be unchanged
+              mNextHintObjectID = destID;
+              if( isHintFilterStringInvalid() ) {
+                  mNextHintIndex = mHintBookmarks[ destID ];
+                  }
+              }
+          else if( tr->newActor > 0 &&
+                   holdingID != tr->newActor ) {
+              // give hint about how what we're holding will change
+              mNextHintObjectID = tr->newActor;
+              if( isHintFilterStringInvalid() ) {
+                  mNextHintIndex = mHintBookmarks[ tr->newTarget ];
+                  }
+              }
+          else if( tr->newTarget > 0 ) {
+              // give hint about changed target after we act on it
+              mNextHintObjectID = tr->newTarget;
+              if( isHintFilterStringInvalid() ) {
+                  mNextHintIndex = mHintBookmarks[ tr->newTarget ];
+                  }
+              }
+          }
+      else {
+          // bare hand
+          // only give hint about hit if no bare-hand action applies
+
+          if( getTrans( 0, destID ) == NULL ) {
+              mNextHintObjectID = destID;
+              if( isHintFilterStringInvalid() ) {
+                  mNextHintIndex = mHintBookmarks[ destID ];
+                  }
+              }
+          }
+    }
+
+
+
+void LivingLifePage::moveTo(int moveDestX, int moveDestY) {
+    LiveObject *ourLiveObject = getOurLiveObject();
+
+    // prepare for various calls to computePathToDest below
+    findClosestPathSpot( ourLiveObject );
+
+    char oldPathExists = ( ourLiveObject->pathToDest != NULL );
+
+    if( oldPathExists ) {
+        savePlayerPath( ourLiveObject );
+        }
+
+
+
+    int oldXD = ourLiveObject->xd;
+    int oldYD = ourLiveObject->yd;
+
+    ourLiveObject->xd = moveDestX;
+    ourLiveObject->yd = moveDestY;
+    ourLiveObject->destTruncated = false;
+
+
+    computePathToDest( ourLiveObject );
+
+
+    if( ourLiveObject->pathToDest == NULL ) {
+        // adjust move to closest possible
+        ourLiveObject->xd = ourLiveObject->closestDestIfPathFailedX;
+        ourLiveObject->yd = ourLiveObject->closestDestIfPathFailedY;
+        ourLiveObject->destTruncated = false;
+
+        if( ourLiveObject->xd == oldXD && ourLiveObject->yd == oldYD ) {
+            // completely blocked in, no path at all toward dest
+
+            if( oldPathExists ) {
+                restoreSavedPath( ourLiveObject );
+                }
+
+
+            // ignore click
+
+            if( nextActionMessageToSend != NULL ) {
+                delete [] nextActionMessageToSend;
+                nextActionMessageToSend = NULL;
+                }
+
+            return;
+            }
+
+        if( oldPathExists ) {
+            freeSavedPath();
+            oldPathExists = false;
+            }
+
+
+        computePathToDest( ourLiveObject );
+
+        if( ourLiveObject->pathToDest == NULL &&
+            ourLiveObject->useWaypoint ) {
+            // waypoint itself may be blocked
+            // try again with no waypoint at all
+            ourLiveObject->useWaypoint = false;
+            computePathToDest( ourLiveObject );
+            }
+
+        if( ourLiveObject->pathToDest == NULL ) {
+            // this happens when our curPos is slightly off of xd,yd
+            // but not a full cell away
+
+            // make a fake path
+            doublePair dest = { (double) ourLiveObject->xd,
+                                (double) ourLiveObject->yd };
+
+            doublePair dir = normalize( sub( dest, 
+                                             ourLiveObject->currentPos ) );
+
+            // fake start, one grid step away
+            doublePair fakeStart = dest;
+
+            if( fabs( dir.x ) > fabs( dir.y ) ) {
+
+                if( dir.x < 0 ) {
+                    fakeStart.x += 1;
+                    }
+                else {
+                    fakeStart.x -= 1;
+                    }
+                }
+            else {
+                if( dir.y < 0 ) {
+                    fakeStart.y += 1;
+                    }
+                else {
+                    fakeStart.y -= 1;
+                    }
+
+                }
+
+
+            ourLiveObject->pathToDest = new GridPos[2];
+
+            ourLiveObject->pathToDest[0].x = (int)fakeStart.x;
+            ourLiveObject->pathToDest[0].y = (int)fakeStart.y;
+
+            ourLiveObject->pathToDest[1].x = ourLiveObject->xd;
+            ourLiveObject->pathToDest[1].y = ourLiveObject->yd;
+
+            ourLiveObject->pathLength = 2;
+            ourLiveObject->currentPathStep = 0;
+            ourLiveObject->numFramesOnCurrentStep = 0;
+            ourLiveObject->onFinalPathStep = false;
+
+            ourLiveObject->currentMoveDirection =
+                normalize(
+                    sub( gridToDouble( ourLiveObject->pathToDest[1] ),
+                         gridToDouble( ourLiveObject->pathToDest[0] ) ) );
+            }
+
+        if( ourLiveObject->xd == oldXD
+            &&
+            ourLiveObject->yd == oldYD ) {
+
+            // truncated path is where we're already going
+            // don't send new move message
+            return;
+            }
+
+
+        moveDestX = ourLiveObject->xd;
+        moveDestY = ourLiveObject->yd;
+
+        if( nextActionMessageToSend != NULL ) {
+            // abort the action, because we can't reach the spot we
+            // want to reach
+            delete [] nextActionMessageToSend;
+            nextActionMessageToSend = NULL;
+            }
+
+        }
+
+
+    if( oldPathExists ) {
+        freeSavedPath();
+        }
+
+
+
+    // send move right away
+    //Thread::staticSleep( 2000 );
+    SimpleVector<char> moveMessageBuffer;
+
+    moveMessageBuffer.appendElementString( "MOVE" );
+    ourLiveObject->lastMoveSequenceNumber ++;
+
+    // start is absolute
+    char *startString =
+        autoSprintf( " %d %d @%d",
+                     sendX( ourLiveObject->pathToDest[0].x ),
+                     sendY( ourLiveObject->pathToDest[0].y ),
+                     ourLiveObject->lastMoveSequenceNumber );
+    moveMessageBuffer.appendElementString( startString );
+    delete [] startString;
+
+    for( int i=1; i<ourLiveObject->pathLength; i++ ) {
+        // rest are relative to start
+        char *stepString = autoSprintf( " %d %d",
+                                     ourLiveObject->pathToDest[i].x
+                                        - ourLiveObject->pathToDest[0].x,
+                                     ourLiveObject->pathToDest[i].y
+                                        - ourLiveObject->pathToDest[0].y );
+
+        moveMessageBuffer.appendElementString( stepString );
+        delete [] stepString;
+        }
+    moveMessageBuffer.appendElementString( "#" );
+
+
+    char *message = moveMessageBuffer.getElementString();
+
+    sendToServerSocket( message );
+
+
+    delete [] message;
+
+    // start moving before we hear back from server
+
+
+    ourLiveObject->inMotion = true;
+
+
+    double floorSpeedMod = computePathSpeedMod( ourLiveObject,
+                                                ourLiveObject->pathLength );
+
+
+    ourLiveObject->moveTotalTime =
+        measurePathLength( ourLiveObject, ourLiveObject->pathLength ) /
+        ( ourLiveObject->lastSpeed * floorSpeedMod );
+
+    ourLiveObject->moveEtaTime = game_getCurrentTime() +
+        ourLiveObject->moveTotalTime;
+
+
+    updateMoveSpeed( ourLiveObject );
+    }
+
+
+char LivingLifePage::moveNearTo(int clickDestX, int clickDestY) {
+    LiveObject *ourLiveObject = getOurLiveObject();
+
+    int mapX = clickDestX - mMapOffsetX + mMapD / 2;
+    int mapY = clickDestY - mMapOffsetY + mMapD / 2;
+
+    int destID = 0;
+
+    if( mapY >= 0 && mapY < mMapD &&
+        mapX >= 0 && mapX < mMapD ) {
+
+        destID = mMap[ mapY * mMapD + mapX ];
+        }
+
+    char canExecute = false;
+    char sideAccess = false;
+    char noBackAccess = false;
+
+    if( destID > 0 && getObject( destID )->sideAccess ) {
+        sideAccess = true;
+        }
+
+    if( destID > 0 && getObject( destID )->noBackAccess ) {
+        noBackAccess = true;
+        }
+
+
+    // direct click on adjacent cells or self cell?
+    if( isGridAdjacent( clickDestX, clickDestY,
+                        ourLiveObject->xd, ourLiveObject->yd )
+        ||
+        ( clickDestX == ourLiveObject->xd &&
+          clickDestY == ourLiveObject->yd ) ) {
+
+        canExecute = true;
+
+        if( sideAccess &&
+            ( clickDestY > ourLiveObject->yd ||
+              clickDestY < ourLiveObject->yd ) ) {
+            // trying to access side-access object from N or S
+            canExecute = false;
+            }
+
+        if( noBackAccess &&
+            clickDestY < ourLiveObject->yd ) {
+            // trying to access noBackAccess object from N
+            canExecute = false;
+            }
+
+        if( canExecute && 
+            clickDestX == ourLiveObject->xd && 
+            clickDestY == ourLiveObject->yd ) {
+            // access from where we're standing
+
+            // make sure result is non-blocking
+            // (else walk to an empty spot before executing action)
+            if( destID > 0 ) {
+
+                int newDestID = 0;
+
+                TransRecord *useTrans = 
+                    getTrans( ourLiveObject->holdingID, destID );
+
+                if( useTrans != NULL ) {
+                    newDestID = useTrans->newTarget;
+                    }
+
+                if( newDestID > 0 && 
+                    getObject( newDestID )->blocksWalking ) {
+                    canExecute = false;
+                    }
+                }
+            }
+        }
+
+    if( !canExecute && getObject( destID )->wide ) {
+        // can't reach main tile on wide object
+        // can we reach a side-wing?
+        // only check where we're actually standing
+        // this is a rare case where we're trapped by a wide object
+        // no problem in making user walk as close as possible manually
+        // to try to escape (so we don't need to overhaul all movement
+        // code to deal with wide objects)
+
+        ObjectRecord *destO = getObject( destID );
+
+        for( int r=0; r<destO->leftBlockingRadius; r++ ) {
+            int testX = clickDestX - r - 1;
+            if( isGridAdjacent( testX, clickDestY,
+                                ourLiveObject->xd, ourLiveObject->yd ) ) {
+                canExecute = true;
+                break;
+                }
+            }
+
+        if( ! canExecute )
+        for( int r=0; r<destO->rightBlockingRadius; r++ ) {
+            int testX = clickDestX + r + 1;
+            if( isGridAdjacent( testX, clickDestY,
+                                ourLiveObject->xd, ourLiveObject->yd ) ) {
+                canExecute = true;
+                break;
+                }
+            }
+        if( canExecute ) {
+            playerActionTargetNotAdjacent = true;
+            }
+        }
+
+    if( ! canExecute ) {
+        // need to move to empty adjacent first, if it exists
+
+        // also consider spot itself in some cases
+
+        // prepare for various calls to computePathToDest below
+        findClosestPathSpot( ourLiveObject );
+
+        int moveDestX = clickDestX;
+        int moveDestY = clickDestY;
+
+        int nDX[5] = { 0, -1, +1, 0, 0 };
+        int nDY[5] = { 0, 0, 0, -1, +1 };
+
+        char foundEmpty = false;
+
+        double closestDist = 9999999;
+
+        char oldPathExists = ( ourLiveObject->pathToDest != NULL );
+        if( oldPathExists ) {
+            savePlayerPath( ourLiveObject );
+            }
+
+        // don't consider dest spot itself generally
+        int nStart = 1;
+
+        int nLimit = 5;
+
+        if( sideAccess ) {
+            // don't consider N or S neighbors
+            nLimit = 3;
+            }
+        else if( noBackAccess ) {
+            // don't consider N neighbor
+            nLimit = 4;
+            }
+
+
+
+        for( int n=nStart; n<nLimit; n++ ) {
+            int x = mapX + nDX[n];
+            int y = mapY + nDY[n];
+
+            if( y >= 0 && y < mMapD &&
+                x >= 0 && x < mMapD ) {
+
+
+                int mapI = y * mMapD + x;
+
+                if( mMap[ mapI ] == 0
+                    ||
+                    ( mMap[ mapI ] != -1 &&
+                      ! getObject( mMap[ mapI ] )->blocksWalking ) ) {
+
+                    int emptyX = clickDestX + nDX[n];
+                    int emptyY = clickDestY + nDY[n];
+
+                    // check if there's a path there
+                    int oldXD = ourLiveObject->xd;
+                    int oldYD = ourLiveObject->yd;
+
+                    // set this temporarily for pathfinding
+                    ourLiveObject->xd = emptyX;
+                    ourLiveObject->yd = emptyY;
+
+                    computePathToDest( ourLiveObject );
+                    double diagPathLength = ourLiveObject->pathLength;
+                    if( ourLiveObject->pathToDest != NULL ) diagPathLength = measurePathLength( ourLiveObject, ourLiveObject->pathLength);
+
+                    if( ourLiveObject->pathToDest != NULL &&
+                        diagPathLength < closestDist ) {
+
+                        // can get there
+
+                        moveDestX = emptyX;
+                        moveDestY = emptyY;
+
+                        closestDist = diagPathLength;
+
+                        foundEmpty = true;
+                        }
+
+                    // restore our old dest
+                    ourLiveObject->xd = oldXD;
+                    ourLiveObject->yd = oldYD;
+
+                    if( n == 0 && foundEmpty ) {
+                        // always prefer tile itself, if that's an option
+                        // based on logic above, even if further
+                        break;
+                        }
+                    }
+
+                }
+            }
+
+          if( !foundEmpty &&
+              ! sideAccess &&
+              ! noBackAccess &&
+              nStart > 0 &&
+              (destID == 0 ||
+                ! getObject( destID )->blocksWalking ) ) {
+
+              // all neighbors blocked
+              // we didn't consider tile itself before
+              // but now we will, as last resort.
+
+              // consider tile itself as dest
+              int oldXD = ourLiveObject->xd;
+              int oldYD = ourLiveObject->yd;
+
+              // set this temporarily for pathfinding
+              ourLiveObject->xd = clickDestX;
+              ourLiveObject->yd = clickDestY;
+
+              computePathToDest( ourLiveObject );
+
+              if( ourLiveObject->pathToDest != NULL  ) {
+
+                  // can get there
+
+                  moveDestX = clickDestX;
+                  moveDestY = clickDestY;
+
+                  foundEmpty = true;
+                  }
+
+              // restore our old dest
+              ourLiveObject->xd = oldXD;
+              ourLiveObject->yd = oldYD; 
+              }
+
+        if( oldPathExists ) {
+            restoreSavedPath( ourLiveObject );
+            }
+
+        if( foundEmpty ) {
+            canExecute = true;
+            }
+        // always try to move as close as possible, even
+        // if we can't actually get close enough to execute action
+        moveTo( moveDestX, moveDestY );
+        }
+    return canExecute;
+    }
+
+
+char LivingLifePage::prepareForActionMessage( int clickDestX, int clickDestY ) {
+    LiveObject *ourLiveObject = getOurLiveObject();
+
+    nextActionEating = false;
+    nextActionDropping = false;
+
+    char canExecute = moveNearTo( clickDestX, clickDestY );
+    if( canExecute ) {
+        if( nextActionMessageToSend != NULL ) {
+            delete [] nextActionMessageToSend;
+            nextActionMessageToSend = NULL;
+            }
+
+        playerActionTargetX = clickDestX;
+        playerActionTargetY = clickDestY;
+
+        ourLiveObject->actionTargetX = clickDestX;
+        ourLiveObject->actionTargetY = clickDestY;
+
+        ourLiveObject->actionTargetTweakX = 0;
+        ourLiveObject->actionTargetTweakY = 0;
+        }
+
+    return canExecute;
+    }
+
+
+
+char hasSpecialBareHandTransition( int destID ) {
+    // check for case where both bare-hand transition
+    // AND pickup applies
+    if( getNumContainerSlots( destID ) == 0 &&
+        ! getObject( destID )->permanent ) {
+
+        TransRecord *bareHandTrans = getTrans( 0, destID );
+
+        if( bareHandTrans != NULL &&
+            bareHandTrans->newTarget != 0 ) {
+
+            // bare hand trans exists, and it's NOT just a
+            // direct "pickup" trans that should always be applied
+            // (from target to new actor)
+            // The bare hand trans leaves something on the ground
+            // meaning that it is transformational (removing
+            // a plate from a stack, tweaking something, etc.)
+
+            return true;
+            }
+        }
+
+        return false;
+    }
+
+
+
+char hasEmptyTileTransition( int holdingID, int floorDestID ) {
+    if( holdingID > 0 ) {
+        ObjectRecord *held =
+            getObject( holdingID );
+
+        if( held->foodValue == 0 ) {
+
+            TransRecord *r =
+                getTrans( holdingID,
+                          -1 );
+
+            if( r != NULL &&
+                r->newTarget != 0 ) {
+
+                // a use-on-ground transition exists!
+                return true;
+                }
+            }
+
+        if( floorDestID > 0 ) {
+            // check if use on floor exists
+            TransRecord *r = 
+                getTrans( holdingID, 
+                          floorDestID );
+
+            if( r != NULL ) {
+                // a use-on-floor transition exists!
+                return true;
+                }
+            }
+        }
+    return false;
+    }
+
+
+
+void LivingLifePage::useAt(int clickDestX, int clickDestY, int destID) {
+    LiveObject *ourLiveObject = getOurLiveObject();
+
+    nextActionEating = false;
+    nextActionDropping = false;
+
+    char canExecute = true;
+    if( //destID != 0 &&
+        ourLiveObject->holdingID > 0 &&
+        getObject( ourLiveObject->holdingID )->useDistance > 1// &&
+        //getTrans( ourLiveObject->holdingID, destID ) != NULL ) {
+        ) {
+        // check if we're close enough to use this from here
+
+        double d = sqrt( ( clickDestX - ourLiveObject->xd ) *
+                         ( clickDestX - ourLiveObject->xd )
+                         +
+                         ( clickDestY - ourLiveObject->yd ) *
+                         ( clickDestY - ourLiveObject->yd ) );
+
+
+        if( getObject( ourLiveObject->holdingID )->useDistance >= d) {
+            canExecute = true;
+            playerActionTargetNotAdjacent = true;
+            }
+        else {
+            // Out of range. Don't want to run headlong into a wolf
+            //canExecute = moveNearTo( clickDestX, clickDestY );
+            }
+        }
+    else {
+        canExecute = moveNearTo( clickDestX, clickDestY );
+        }
+    if( canExecute ) {
+        if( nextActionMessageToSend != NULL ) {
+            delete [] nextActionMessageToSend;
+            nextActionMessageToSend = NULL;
+            }
+
+        nextActionMessageToSend = 
+            autoSprintf( "USE %d %d %d#",
+                         sendX( clickDestX ), 
+                         sendY( clickDestY ),
+                         destID );
+
+        playerActionTargetX = clickDestX;
+        playerActionTargetY = clickDestY;
+
+        ourLiveObject->actionTargetX = clickDestX;
+        ourLiveObject->actionTargetY = clickDestY;
+
+        ourLiveObject->actionTargetTweakX = 0;
+        ourLiveObject->actionTargetTweakY = 0;
+        }
+    }
+
+
+void LivingLifePage::dropAt(int clickDestX, int clickDestY) {
+    if( prepareForActionMessage( clickDestX, clickDestY ) ) {
+        nextActionMessageToSend = 
+            autoSprintf( "DROP %d %d -1#",
+                         sendX( clickDestX ), 
+                         sendY( clickDestY ) );
+
+        nextActionDropping = true;
+        }
+    }
+
+
+void LivingLifePage::removeAt( int clickDestX, int clickDestY ) {
+    if( prepareForActionMessage( clickDestX, clickDestY ) ) {
+        nextActionMessageToSend = 
+            autoSprintf( "REMV %d %d -1#",
+                         sendX( clickDestX ), 
+                         sendY( clickDestY ) );
+        }
+    }
+
+
+void LivingLifePage::pickupBabyAt( int clickDestX, int clickDestY, int targetID ) {
+    if( prepareForActionMessage( clickDestX, clickDestY ) ) {
+        if( targetID > 0 ) {
+            nextActionMessageToSend =
+                autoSprintf( "BABY %d %d %d#",
+                             sendX( clickDestX ),
+                             sendY( clickDestY ),
+                             targetID );
+            }
+        else {
+            nextActionMessageToSend =
+                autoSprintf( "BABY %d %d#",
+                             sendX( clickDestX ),
+                             sendY( clickDestY ) );
+            }
+        }
+    }
+
+
+void LivingLifePage::useOnOtherAt( int clickDestX, int clickDestY, int targetID ) {
+    if( prepareForActionMessage( clickDestX, clickDestY ) ) {
+        if( targetID > 0 ) {
+            nextActionMessageToSend =
+                autoSprintf( "UBABY %d %d -1 %d#",
+                             sendX( clickDestX ),
+                             sendY( clickDestY ),
+                             targetID );
+            }
+        else {
+            nextActionMessageToSend =
+                autoSprintf( "UBABY %d %d -1#",
+                             sendX( clickDestX ),
+                             sendY( clickDestY ) );
+            }
+        }
+    }
+
+
+void LivingLifePage::killAt( int clickDestX, int clickDestY, int targetID ) {
+    if( targetID <= 0 ) return;
+
+    if( nextActionMessageToSend != NULL ) {
+        delete [] nextActionMessageToSend;
+        nextActionMessageToSend = NULL;
+        }
+
+    nextActionMessageToSend =
+        autoSprintf( "KILL %d %d %d#",
+                     sendX( clickDestX ),
+                     sendY( clickDestY ),
+                     targetID );
+
+    sendToServerSocket( nextActionMessageToSend );
+    delete [] nextActionMessageToSend;
+    nextActionMessageToSend = NULL;
+
+    LiveObject *ourLiveObject = getOurLiveObject();
+    ourLiveObject->killMode = true;
+    ourLiveObject->killWithID = ourLiveObject->holdingID;
+
+    moveNearTo( clickDestX, clickDestY );
+    }
 
 
 
@@ -23355,8 +24321,6 @@ void LivingLifePage::pointerDown( float inX, float inY ) {
         }
     
 
-    // prepare for various calls to computePathToDest below
-    findClosestPathSpot( ourLiveObject );
     
     
 
@@ -23718,7 +24682,6 @@ void LivingLifePage::pointerDown( float inX, float inY ) {
     int moveDestX = clickDestX;
     int moveDestY = clickDestY;
     
-    char mustMove = false;
 
 
     
@@ -23726,61 +24689,7 @@ void LivingLifePage::pointerDown( float inX, float inY ) {
 
     if( destID > 0 && p.hitAnObject ) {
         
-        if( ourLiveObject->holdingID > 0 ) {
-            TransRecord *tr = getTrans( ourLiveObject->holdingID, destID );
-            
-            if( tr == NULL ) {
-                // try defaul transition
-                // tr = getTrans( -2, destID );
-                
-                // for now, DO NOT consider default transition
-                // no main transition for this held object applies
-                // so we should probably give a hint about what CAN apply
-                // to the target object.
-
-                // Default transitions are currently just used to make
-                // something react to the player (usually for animals getting
-                // startled), not to actually accomplish
-                // something
-
-                // so we should show hints about the target object BEFORE it
-                // went into its (temporary) reaction state. 
-                }
-            
-            if( tr == NULL || tr->newTarget == destID ) {
-                // give hint about dest object which will be unchanged 
-                mNextHintObjectID = destID;
-                if( isHintFilterStringInvalid() ) {
-                    mNextHintIndex = mHintBookmarks[ destID ];
-                    }
-                }
-            else if( tr->newActor > 0 && 
-                     ourLiveObject->holdingID != tr->newActor ) {
-                // give hint about how what we're holding will change
-                mNextHintObjectID = tr->newActor;
-                if( isHintFilterStringInvalid() ) {
-                    mNextHintIndex = mHintBookmarks[ tr->newTarget ];
-                    }
-                }
-            else if( tr->newTarget > 0 ) {
-                // give hint about changed target after we act on it
-                mNextHintObjectID = tr->newTarget;
-                if( isHintFilterStringInvalid() ) {
-                    mNextHintIndex = mHintBookmarks[ tr->newTarget ];
-                    }
-                }
-            }
-        else {
-            // bare hand
-            // only give hint about hit if no bare-hand action applies
-
-            if( getTrans( 0, destID ) == NULL ) {
-                mNextHintObjectID = destID;
-                if( isHintFilterStringInvalid() ) {
-                    mNextHintIndex = mHintBookmarks[ destID ];
-                    }
-                }
-            }
+        hintForObjectInteraction( ourLiveObject->holdingID, destID );
         }
 
     
@@ -24145,7 +25054,7 @@ void LivingLifePage::pointerDown( float inX, float inY ) {
         // a move to an empty spot where we're not already standing
         // can interrupt current move
         
-        mustMove = true;
+        moveTo( clickDestX, clickDestY );
         }
     else if( ( modClick && 
                // we can right click on an empty tile or full tile if
@@ -24164,276 +25073,8 @@ void LivingLifePage::pointerDown( float inX, float inY ) {
         // use/drop modifier
         // OR pick up action
             
-        
-        char canExecute = false;
-        char sideAccess = false;
-        char noBackAccess = false;
-        
-        if( destID > 0 && getObject( destID )->sideAccess ) {
-            sideAccess = true;
-            }
-        
-        if( destID > 0 && getObject( destID )->noBackAccess ) {
-            noBackAccess = true;
-            }
-        
-
-        // direct click on adjacent cells or self cell?
-        if( isGridAdjacent( clickDestX, clickDestY,
-                            ourLiveObject->xd, ourLiveObject->yd )
-            || 
-            ( clickDestX == ourLiveObject->xd && 
-              clickDestY == ourLiveObject->yd ) ) {
-            
-            canExecute = true;
-            
-            if( sideAccess &&
-                ( clickDestY > ourLiveObject->yd ||
-                  clickDestY < ourLiveObject->yd ) ) {
-                // trying to access side-access object from N or S
-                canExecute = false;
-                }
-            if( noBackAccess &&
-                ( clickDestY < ourLiveObject->yd ) ) {
-                // trying to access noBackAccess object from N
-                canExecute = false;
-                }
-
-            if( canExecute && 
-                clickDestX == ourLiveObject->xd && 
-                clickDestY == ourLiveObject->yd ) {
-                // access from where we're standing
-                
-                // make sure result is non-blocking
-                // (else walk to an empty spot before executing action)
-                if( destID > 0 ) {
-                    
-                    int newDestID = 0;
-                    
-                    TransRecord *useTrans = 
-                        getTrans( ourLiveObject->holdingID, destID );
-                    
-                    if( useTrans != NULL ) {
-                        newDestID = useTrans->newTarget;
-                        }
-                    
-                    if( newDestID > 0 && 
-                        getObject( newDestID )->blocksWalking ) {
-                        canExecute = false;
-                        }
-                    }
-                }
-            }
-
-
-        if( ! canExecute ) {
-            // need to move to empty adjacent first, if it exists
-            
-            // also consider spot itself in some cases
-            
-            int nDX[5] = { 0, -1, +1, 0, 0 };
-            int nDY[5] = { 0, 0, 0, -1, +1 };
-            
-            char foundEmpty = false;
-            
-            int closestDist = 9999999;
-
-            char oldPathExists = ( ourLiveObject->pathToDest != NULL );
-
-            if( oldPathExists ) {
-                savePlayerPath( ourLiveObject );
-                }
-            
-            // don't consider dest spot itself generally
-            int nStart = 1;
-            
-            int nLimit = 5;
-            
-            if( sideAccess ) {
-                // don't consider N or S neighbors
-                nLimit = 3;
-                }
-            else if( noBackAccess ) {
-                // don't consider N neighbor
-                nLimit = 4;
-                }
-            else if( destID > 0 &&
-                     ( ourLiveObject->holdingID <= 0 ||
-                       ( getObject( ourLiveObject->holdingID )->permanent &&
-                         strstr( getObject( ourLiveObject->holdingID )->
-                                 description, "sick" ) != NULL ) )
-                     &&
-                     getObject( destID )->permanent &&
-                     ! getObject( destID )->blocksWalking ) {
-                
-                TransRecord *handTrans = NULL;
-                if( ourLiveObject->holdingID == 0 ) {
-                    handTrans = getTrans( 0, destID );
-                    }
-                
-                if( handTrans == NULL ||
-                    ( handTrans->newActor != 0 &&
-                      getObject( handTrans->newActor )->foodValue > 0 &&
-                        handTrans->newTarget != 0 &&
-                      ! getObject( handTrans->newTarget )->blocksWalking ) ) {
-                    // walk to tile itself if target is permanent
-                    // and not blocking, and hand is empty
-                    // AND this will result in something still
-                    // on the ground (so it's not a transforming pick-up,
-                    // like pulling an onion).
-                    // and the new thing on the ground is not blocking
-                    // (so we're not closing a door)
-                    // and what you get in the hand is edible
-                    // (example:  picking berries from behind the bush)
-                    //
-                    // this is the main situation where you'd want to
-                    // click the same target and yourself
-                    // multiple times in a row, so having yourself
-                    // as close as possible to the target matters
-                    nStart = 0;
-                    }
-                }
-
-
-
-            for( int n=nStart; n<nLimit; n++ ) {
-                int x = mapX + nDX[n];
-                int y = mapY + nDY[n];
-
-                if( y >= 0 && y < mMapD &&
-                    x >= 0 && x < mMapD ) {
-                 
-                    
-                    int mapI = y * mMapD + x;
-                    
-                    if( mMap[ mapI ] == 0
-                        ||
-                        ( mMap[ mapI ] != -1 && 
-                          ! getObject( mMap[ mapI ] )->blocksWalking ) ) {
-                        
-                        int emptyX = clickDestX + nDX[n];
-                        int emptyY = clickDestY + nDY[n];
-
-                        // check if there's a path there
-                        int oldXD = ourLiveObject->xd;
-                        int oldYD = ourLiveObject->yd;
-                        
-                        // set this temporarily for pathfinding
-                        ourLiveObject->xd = emptyX;
-                        ourLiveObject->yd = emptyY;
-                        
-                        computePathToDest( ourLiveObject );
-                        
-                        if( ourLiveObject->pathToDest != NULL &&
-                            ourLiveObject->pathLength < closestDist ) {
-                            
-                            // can get there
-                            
-                            moveDestX = emptyX;
-                            moveDestY = emptyY;
-                            
-                            closestDist = ourLiveObject->pathLength;
-                            
-                            foundEmpty = true;
-                            }
-                        
-                        // restore our old dest
-                        ourLiveObject->xd = oldXD;
-                        ourLiveObject->yd = oldYD;    
-
-                        if( n == 0 && foundEmpty ) {
-                            // always prefer tile itself, if that's an option
-                            // based on logic above, even if further
-                            break;
-                            }
-                        }
-                    
-                    }
-                }
-
-
-            if( !foundEmpty && 
-                ! sideAccess &&
-                nStart > 0 &&
-                ( destID == 0 ||
-                  ! getObject( destID )->blocksWalking ) ) {
-                
-                // all neighbors blocked
-                // we didn't consider tile itself before
-                // but now we will, as last resort.
-
-                // consider tile itself as dest
-                int oldXD = ourLiveObject->xd;
-                int oldYD = ourLiveObject->yd;
-                        
-                // set this temporarily for pathfinding
-                ourLiveObject->xd = clickDestX;
-                ourLiveObject->yd = clickDestY;
-                        
-                computePathToDest( ourLiveObject );
-                        
-                if( ourLiveObject->pathToDest != NULL  ) {
-                            
-                    // can get there
-                    
-                    moveDestX = clickDestX;
-                    moveDestY = clickDestY;
-                            
-                    foundEmpty = true;
-                    }
-                        
-                // restore our old dest
-                ourLiveObject->xd = oldXD;
-                ourLiveObject->yd = oldYD; 
-                }
-            
-            
-            if( oldPathExists ) {
-                restoreSavedPath( ourLiveObject );
-                }
-
-            if( foundEmpty ) {
-                canExecute = true;
-                }
-            // always try to move as close as possible, even
-            // if we can't actually get close enough to execute action
-            mustMove = true;
-            }
-        
+        char canExecute = moveNearTo( clickDestX, clickDestY );
 
-        if( !canExecute && getObject( destID )->wide ) {
-            // can't reach main tile on wide object
-            // can we reach a side-wing?
-            // only check where we're actually standing
-            // this is a rare case where we're trapped by a wide object
-            // no problem in making user walk as close as possible manually
-            // to try to escape (so we don't need to overhaul all movement
-            // code to deal with wide objects)
-            ObjectRecord *destO = getObject( destID );
-            
-            for( int r=0; r<destO->leftBlockingRadius; r++ ) {
-                int testX = clickDestX - r - 1;
-                if( isGridAdjacent( testX, clickDestY,
-                                    ourLiveObject->xd, ourLiveObject->yd ) ) {
-                    canExecute = true;
-                    break;
-                    }
-                }
-            
-            if( ! canExecute )
-            for( int r=0; r<destO->rightBlockingRadius; r++ ) {
-                int testX = clickDestX + r + 1;
-                if( isGridAdjacent( testX, clickDestY,
-                                    ourLiveObject->xd, ourLiveObject->yd ) ) {
-                    canExecute = true;
-                    break;
-                    }
-                }
-            if( canExecute ) {
-                mustMove = false;
-                playerActionTargetNotAdjacent = true;
-                }
-            }
         
         
 
@@ -24475,47 +25116,9 @@ void LivingLifePage::pointerDown( float inX, float inY ) {
                 // check for other special case
                 // a use-on-ground transition or use-on-floor transition
 
-                if( ourLiveObject->holdingID > 0 ) {
-                        
-                    ObjectRecord *held = 
-                        getObject( ourLiveObject->holdingID );
-                        
-                    char foundAlt = false;
-                        
-                    if( held->foodValue == 0 &&
-                        destObjInClickedTile == 0 ) {
-                        // a truly empty spot where use-on-bare-ground
-                        // can happen
-
-                        TransRecord *r = 
-                            getTrans( ourLiveObject->holdingID,
-                                      -1 );
-                            
-                        if( r != NULL &&
-                            r->newTarget != 0 ) {
-                                
-                            // a use-on-ground transition exists!
-                                
-                            // override the drop action
-                            action = "USE";
-                            foundAlt = true;
-                            }
-                        }
-
-                    if( !foundAlt && floorDestID > 0 ) {
-                        // check if use on floor exists
-                        TransRecord *r = 
-                            getTrans( ourLiveObject->holdingID, 
-                                      floorDestID );
-                                
-                        if( r != NULL ) {
-                            // a use-on-floor transition exists!
-                                
-                            // override the drop action
-                            action = "USE";
-                                
-                            }
-                        }
+                if( destObjInClickedTile == 0 &&
+                    hasEmptyTileTransition( ourLiveObject->holdingID, floorDestID ) ) {
+                    action = "USE";
                     }
                 }
             else if( destID != 0 &&
@@ -24696,216 +25299,6 @@ void LivingLifePage::pointerDown( float inX, float inY ) {
             delete [] extra;
             }
         }
-    
-
-
-    
-    if( mustMove ) {
-
-        char oldPathExists = ( ourLiveObject->pathToDest != NULL );
-        
-        if( oldPathExists ) {
-            savePlayerPath( ourLiveObject );
-            }
-
-
-
-        int oldXD = ourLiveObject->xd;
-        int oldYD = ourLiveObject->yd;
-        
-        ourLiveObject->xd = moveDestX;
-        ourLiveObject->yd = moveDestY;
-        ourLiveObject->destTruncated = false;
-
-
-
-        
-        
-
-        computePathToDest( ourLiveObject );
-
-        
-        if( ourLiveObject->pathToDest == NULL ) {
-            // adjust move to closest possible
-            ourLiveObject->xd = ourLiveObject->closestDestIfPathFailedX;
-            ourLiveObject->yd = ourLiveObject->closestDestIfPathFailedY;
-            ourLiveObject->destTruncated = false;
-            
-            if( ourLiveObject->xd == oldXD && ourLiveObject->yd == oldYD ) {
-                // completely blocked in, no path at all toward dest
-                
-                if( oldPathExists ) {
-                    restoreSavedPath( ourLiveObject );
-                    }
-                    
-
-                // ignore click
-                
-                if( nextActionMessageToSend != NULL ) {
-                    delete [] nextActionMessageToSend;
-                    nextActionMessageToSend = NULL;
-                    }
-                
-                return;
-                }
-
-            if( oldPathExists ) {
-                freeSavedPath();
-                oldPathExists = false;
-                }
-            
-
-            computePathToDest( ourLiveObject );
-            
-            if( ourLiveObject->pathToDest == NULL &&
-                ourLiveObject->useWaypoint ) {
-                // waypoint itself may be blocked
-                // try again with no waypoint at all
-                ourLiveObject->useWaypoint = false;
-                computePathToDest( ourLiveObject );
-                }
-
-            if( ourLiveObject->pathToDest == NULL ) {
-                // this happens when our curPos is slightly off of xd,yd
-                // but not a full cell away
-
-                // make a fake path
-                doublePair dest = { (double) ourLiveObject->xd,
-                                    (double) ourLiveObject->yd };
-                
-                doublePair dir = normalize( sub( dest, 
-                                                 ourLiveObject->currentPos ) );
-
-                // fake start, one grid step away
-                doublePair fakeStart = dest;
-
-                if( fabs( dir.x ) > fabs( dir.y ) ) {
-                    
-                    if( dir.x < 0 ) {
-                        fakeStart.x += 1;
-                        }
-                    else {
-                        fakeStart.x -= 1;
-                        }
-                    }
-                else {
-                    if( dir.y < 0 ) {
-                        fakeStart.y += 1;
-                        }
-                    else {
-                        fakeStart.y -= 1;
-                        }
-                    
-                    }
-                
-                
-                ourLiveObject->pathToDest = new GridPos[2];
-                
-                ourLiveObject->pathToDest[0].x = (int)fakeStart.x;
-                ourLiveObject->pathToDest[0].y = (int)fakeStart.y;
-                
-                ourLiveObject->pathToDest[1].x = ourLiveObject->xd;
-                ourLiveObject->pathToDest[1].y = ourLiveObject->yd;
-                
-                ourLiveObject->pathLength = 2;
-                ourLiveObject->currentPathStep = 0;
-                ourLiveObject->numFramesOnCurrentStep = 0;
-                ourLiveObject->onFinalPathStep = false;
-                
-                ourLiveObject->currentMoveDirection =
-                    normalize( 
-                        sub( gridToDouble( ourLiveObject->pathToDest[1] ), 
-                             gridToDouble( ourLiveObject->pathToDest[0] ) ) );
-                }
-
-            if( ourLiveObject->xd == oldXD 
-                &&
-                ourLiveObject->yd == oldYD ) {
-                
-                // truncated path is where we're already going
-                // don't send new move message
-                return;
-                }
-
-
-            moveDestX = ourLiveObject->xd;
-            moveDestY = ourLiveObject->yd;
-            
-            if( nextActionMessageToSend != NULL ) {
-                // abort the action, because we can't reach the spot we
-                // want to reach
-                delete [] nextActionMessageToSend;
-                nextActionMessageToSend = NULL;
-                }
-            
-            }
-        
-        
-        if( oldPathExists ) {
-            freeSavedPath();
-            }
-            
-
-
-        // send move right away
-        //Thread::staticSleep( 2000 );
-        SimpleVector<char> moveMessageBuffer;
-        
-        moveMessageBuffer.appendElementString( "MOVE" );
-        ourLiveObject->lastMoveSequenceNumber ++;
-        
-        // start is absolute
-        char *startString = 
-            autoSprintf( " %d %d @%d", 
-                         sendX( ourLiveObject->pathToDest[0].x ),
-                         sendY( ourLiveObject->pathToDest[0].y ),
-                         ourLiveObject->lastMoveSequenceNumber );
-        moveMessageBuffer.appendElementString( startString );
-        delete [] startString;
-        
-        for( int i=1; i<ourLiveObject->pathLength; i++ ) {
-            // rest are relative to start
-            char *stepString = autoSprintf( " %d %d", 
-                                         ourLiveObject->pathToDest[i].x
-                                            - ourLiveObject->pathToDest[0].x,
-                                         ourLiveObject->pathToDest[i].y
-                                            - ourLiveObject->pathToDest[0].y );
-            
-            moveMessageBuffer.appendElementString( stepString );
-            delete [] stepString;
-            }
-        moveMessageBuffer.appendElementString( "#" );
-        
-
-        char *message = moveMessageBuffer.getElementString();
-
-        sendToServerSocket( message );
-
-
-        delete [] message;
-
-        // start moving before we hear back from server
-
-        
-        ourLiveObject->inMotion = true;
-
-
-
-
-        double floorSpeedMod = computePathSpeedMod( ourLiveObject,
-                                                    ourLiveObject->pathLength );
-        
-
-        ourLiveObject->moveTotalTime = 
-            measurePathLength( ourLiveObject, ourLiveObject->pathLength ) / 
-            ( ourLiveObject->lastSpeed * floorSpeedMod );
-
-        ourLiveObject->moveEtaTime = game_getCurrentTime() +
-            ourLiveObject->moveTotalTime;
-
-            
-        updateMoveSpeed( ourLiveObject );
-        }    
     }
 
 
diff --git a/gameSource/LivingLifePage.h b/gameSource/LivingLifePage.h
index d662d424e..d56b4968a 100644
--- a/gameSource/LivingLifePage.h
+++ b/gameSource/LivingLifePage.h
@@ -440,6 +440,24 @@ typedef struct PointerHitRecord {
 
 
 
+typedef struct CellHitRecord {
+        int cellX;
+        int cellY;
+        int mapX;
+        int mapY;
+        int destID;
+        int floorDestID;
+        int destNumContained;
+    } CellHitRecord;
+
+typedef struct PersonHitRecord {
+        int cellX;
+        int cellY;
+        int targetID;
+    } PersonHitRecord;
+
+
+
 typedef struct OldArrow {
         int i;
         float heat;
@@ -962,6 +980,18 @@ class LivingLifePage : public GamePage, public ActionListener {
         // forces next pointerDown call to avoid everything but ground clicks
         char mForceGroundClick;
         
+        void checkForCellHit( CellHitRecord& inRecord );
+        void checkForPersonHit( PersonHitRecord& inRecord );
+        void hintForObjectInteraction( int holdingID, int destID );
+        void moveTo( int moveDestX, int moveDestY );
+        char moveNearTo( int clickDestX, int clickDestY );
+        char prepareForActionMessage( int clickDestX, int clickDestY );
+        void useAt( int clickDestX, int clickDestY, int destID = -1 );
+        void dropAt( int clickDestX, int clickDestY );
+        void removeAt( int clickDestX, int clickDestY );
+        void pickupBabyAt( int clickDestX, int clickDestY, int targetID = 0 );
+        void useOnOtherAt( int clickDestX, int clickDestY, int targetID = 0 );
+        void killAt( int clickDestX, int clickDestY, int targetID = 0 );
 
 
         LiveObject *getOurLiveObject();
