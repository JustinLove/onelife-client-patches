diff --git a/gameSource/LivingLifePage.cpp b/gameSource/LivingLifePage.cpp
index cfdbe5c9..c1fbdd78 100644
--- a/gameSource/LivingLifePage.cpp
+++ b/gameSource/LivingLifePage.cpp
@@ -18504,6 +18504,615 @@ char LivingLifePage::getCellBlocksWalking( int inMapX, int inMapY ) {
 
 
 
+void LivingLifePage::checkForCellHit( CellHitRecord& inRecord ) {
+    float worldMouseX, worldMouseY;
+
+    screenToWorld( lastScreenMouseX,
+            lastScreenMouseY,
+            &worldMouseX,
+            &worldMouseY );
+    inRecord.cellX = lrintf( ( worldMouseX ) / CELL_D );
+    inRecord.cellY = lrintf( ( worldMouseY ) / CELL_D );
+
+    inRecord.destID = 0;
+    inRecord.floorDestID = 0;
+    inRecord.destNumContained = 0;
+
+    int mapX = inRecord.cellX - mMapOffsetX + mMapD / 2;
+    int mapY = inRecord.cellY - mMapOffsetY + mMapD / 2;
+    if( mapY >= 0 && mapY < mMapD &&
+        mapX >= 0 && mapX < mMapD ) {
+
+        inRecord.destID = mMap[ mapY * mMapD + mapX ];
+        inRecord.floorDestID = mMapFloors[ mapY * mMapD + mapX ];
+        inRecord.destNumContained = mMapContainedStacks[ mapY * mMapD + mapX ].size();
+        }
+    }
+
+
+
+void LivingLifePage::moveTo(int moveDestX, int moveDestY) {
+    LiveObject *ourLiveObject = getOurLiveObject();
+
+    int oldXD = ourLiveObject->xd;
+    int oldYD = ourLiveObject->yd;
+    
+    ourLiveObject->xd = moveDestX;
+    ourLiveObject->yd = moveDestY;
+    ourLiveObject->destTruncated = false;
+
+    ourLiveObject->inMotion = true;
+
+
+    GridPos *oldPathToDest = NULL;
+    int oldPathLength = 0;
+    int oldCurrentPathStep = 0;
+    
+    if( ourLiveObject->pathToDest != NULL ) {
+        oldPathLength = ourLiveObject->pathLength;
+        oldPathToDest = new GridPos[ oldPathLength ];
+
+        memcpy( oldPathToDest, ourLiveObject->pathToDest,
+                sizeof( GridPos ) * ourLiveObject->pathLength );
+        oldCurrentPathStep = ourLiveObject->currentPathStep;
+        }
+    
+
+    computePathToDest( ourLiveObject );
+
+    
+    if( ourLiveObject->pathToDest == NULL ) {
+        // adjust move to closest possible
+        ourLiveObject->xd = ourLiveObject->closestDestIfPathFailedX;
+        ourLiveObject->yd = ourLiveObject->closestDestIfPathFailedY;
+        ourLiveObject->destTruncated = false;
+        
+        if( ourLiveObject->xd == oldXD && ourLiveObject->yd == oldYD ) {
+            // completely blocked in, no path at all toward dest
+            
+            if( oldPathToDest != NULL ) {
+                // restore it
+                ourLiveObject->pathToDest = oldPathToDest;
+                ourLiveObject->pathLength = oldPathLength;
+                ourLiveObject->currentPathStep = oldCurrentPathStep;
+                oldPathToDest = NULL;
+                }
+            
+                
+
+            // ignore click
+            
+            if( nextActionMessageToSend != NULL ) {
+                delete [] nextActionMessageToSend;
+                nextActionMessageToSend = NULL;
+                }
+            ourLiveObject->inMotion = false;
+            return;
+            }
+
+        if( oldPathToDest != NULL ) {
+            delete [] oldPathToDest;
+            oldPathToDest = NULL;
+            }
+        
+
+        computePathToDest( ourLiveObject );
+        
+        if( ourLiveObject->pathToDest == NULL &&
+            ourLiveObject->useWaypoint ) {
+            // waypoint itself may be blocked
+            // try again with no waypoint at all
+            ourLiveObject->useWaypoint = false;
+            computePathToDest( ourLiveObject );
+            }
+
+        if( ourLiveObject->pathToDest == NULL ) {
+            // this happens when our curPos is slightly off of xd,yd
+            // but not a full cell away
+
+            // make a fake path
+            doublePair dest = { (double) ourLiveObject->xd,
+                                (double) ourLiveObject->yd };
+            
+            doublePair dir = normalize( sub( dest, 
+                                             ourLiveObject->currentPos ) );
+
+            // fake start, one grid step away
+            doublePair fakeStart = dest;
+
+            if( fabs( dir.x ) > fabs( dir.y ) ) {
+                
+                if( dir.x < 0 ) {
+                    fakeStart.x += 1;
+                    }
+                else {
+                    fakeStart.x -= 1;
+                    }
+                }
+            else {
+                if( dir.y < 0 ) {
+                    fakeStart.y += 1;
+                    }
+                else {
+                    fakeStart.y -= 1;
+                    }
+                
+                }
+            
+            
+            ourLiveObject->pathToDest = new GridPos[2];
+            
+            ourLiveObject->pathToDest[0].x = (int)fakeStart.x;
+            ourLiveObject->pathToDest[0].y = (int)fakeStart.y;
+            
+            ourLiveObject->pathToDest[1].x = ourLiveObject->xd;
+            ourLiveObject->pathToDest[1].y = ourLiveObject->yd;
+            
+            ourLiveObject->pathLength = 2;
+            ourLiveObject->currentPathStep = 0;
+            ourLiveObject->numFramesOnCurrentStep = 0;
+            ourLiveObject->onFinalPathStep = false;
+            
+            ourLiveObject->currentMoveDirection =
+                normalize( 
+                    sub( gridToDouble( ourLiveObject->pathToDest[1] ), 
+                         gridToDouble( ourLiveObject->pathToDest[0] ) ) );
+            }
+
+        if( ourLiveObject->xd == oldXD 
+            &&
+            ourLiveObject->yd == oldYD ) {
+            
+            // truncated path is where we're already going
+            // don't send new move message
+            return;
+            }
+
+
+        moveDestX = ourLiveObject->xd;
+        moveDestY = ourLiveObject->yd;
+        
+        if( nextActionMessageToSend != NULL ) {
+            // abort the action, because we can't reach the spot we
+            // want to reach
+            delete [] nextActionMessageToSend;
+            nextActionMessageToSend = NULL;
+            }
+        
+        }
+    
+    
+    if( oldPathToDest != NULL ) {
+        delete [] oldPathToDest;
+        oldPathToDest = NULL;
+        }
+        
+
+
+    // send move right away
+    //Thread::staticSleep( 2000 );
+    SimpleVector<char> moveMessageBuffer;
+    
+    moveMessageBuffer.appendElementString( "MOVE" );
+    ourLiveObject->lastMoveSequenceNumber ++;
+    
+    // start is absolute
+    char *startString = 
+        autoSprintf( " %d %d @%d", 
+                     sendX( ourLiveObject->pathToDest[0].x ),
+                     sendY( ourLiveObject->pathToDest[0].y ),
+                     ourLiveObject->lastMoveSequenceNumber );
+    moveMessageBuffer.appendElementString( startString );
+    delete [] startString;
+    
+    for( int i=1; i<ourLiveObject->pathLength; i++ ) {
+        // rest are relative to start
+        char *stepString = autoSprintf( " %d %d", 
+                                     ourLiveObject->pathToDest[i].x
+                                        - ourLiveObject->pathToDest[0].x,
+                                     ourLiveObject->pathToDest[i].y
+                                        - ourLiveObject->pathToDest[0].y );
+        
+        moveMessageBuffer.appendElementString( stepString );
+        delete [] stepString;
+        }
+    moveMessageBuffer.appendElementString( "#" );
+    
+
+    char *message = moveMessageBuffer.getElementString();
+
+    sendToServerSocket( message );
+
+
+    delete [] message;
+
+    // start moving before we hear back from server
+
+
+
+    double floorSpeedMod = computePathSpeedMod( ourLiveObject,
+                                                ourLiveObject->pathLength );
+    
+
+    ourLiveObject->moveTotalTime = 
+        measurePathLength( ourLiveObject, ourLiveObject->pathLength ) / 
+        ( ourLiveObject->lastSpeed * floorSpeedMod );
+
+    ourLiveObject->moveEtaTime = game_getCurrentTime() +
+        ourLiveObject->moveTotalTime;
+
+        
+    updateMoveSpeed( ourLiveObject );
+    }
+
+
+char LivingLifePage::moveNearTo(int clickDestX, int clickDestY) {
+    LiveObject *ourLiveObject = getOurLiveObject();
+
+    int mapX = clickDestX - mMapOffsetX + mMapD / 2;
+    int mapY = clickDestY - mMapOffsetY + mMapD / 2;    
+
+    int destID = 0;
+
+    if( mapY >= 0 && mapY < mMapD &&
+        mapX >= 0 && mapX < mMapD ) {
+        
+        destID = mMap[ mapY * mMapD + mapX ];
+        }
+
+    char canExecute = false;
+    char sideAccess = false;
+    
+    if( destID > 0 && getObject( destID )->sideAccess ) {
+        sideAccess = true;
+        }
+    
+
+    // direct click on adjacent cells or self cell?
+    if( isGridAdjacent( clickDestX, clickDestY,
+                        ourLiveObject->xd, ourLiveObject->yd )
+        || 
+        ( clickDestX == ourLiveObject->xd && 
+          clickDestY == ourLiveObject->yd ) ) {
+        
+        canExecute = true;
+        
+        if( sideAccess &&
+            ( clickDestY > ourLiveObject->yd ||
+              clickDestY < ourLiveObject->yd ) ) {
+            // trying to access side-access object from N or S
+            canExecute = false;
+            }
+        }
+
+
+    if( ! canExecute ) {
+        // need to move to empty adjacent first, if it exists
+        
+        // also consider spot itself in some cases
+
+        int moveDestX = clickDestX;
+        int moveDestY = clickDestY;
+        
+        int nDX[5] = { 0, -1, +1, 0, 0 };
+        int nDY[5] = { 0, 0, 0, -1, +1 };
+        
+        char foundEmpty = false;
+        
+        int closestDist = 9999999;
+
+        char oldPathExists = ( ourLiveObject->pathToDest != NULL );
+        
+        // don't consider dest spot itself generally
+        int nStart = 1;
+        
+        int nLimit = 5;
+        
+        if( sideAccess ) {
+            // don't consider N or S neighbors
+            nLimit = 3;
+            }
+        else if( destID > 0 &&
+                 ourLiveObject->holdingID == 0 && 
+                 getObject( destID )->permanent &&
+                 ! getObject( destID )->blocksWalking ) {
+            
+            TransRecord *handTrans = getTrans( 0, destID );
+            
+            if( handTrans == NULL ||
+                ( handTrans->newActor != 0 &&
+                  getObject( handTrans->newActor )->foodValue > 0 &&
+                    handTrans->newTarget != 0 &&
+                  ! getObject( handTrans->newTarget )->blocksWalking ) ) {
+                // walk to tile itself if target is permanent
+                // and not blocking, and hand is empty
+                // AND this will result in something still
+                // on the ground (so it's not a transforming pick-up,
+                // like pulling an onion).
+                // and the new thing on the ground is not blocking
+                // (so we're not closing a door)
+                // and what you get in the hand is edible
+                // (example:  picking berries from behind the bush)
+                //
+                // this is the main situation where you'd want to
+                // click the same target and yourself
+                // multiple times in a row, so having yourself
+                // as close as possible to the target matters
+                nStart = 0;
+                }
+            }
+
+
+
+        for( int n=nStart; n<nLimit; n++ ) {
+            int x = mapX + nDX[n];
+            int y = mapY + nDY[n];
+
+            if( y >= 0 && y < mMapD &&
+                x >= 0 && x < mMapD ) {
+             
+                
+                int mapI = y * mMapD + x;
+                
+                if( mMap[ mapI ] == 0
+                    ||
+                    ( mMap[ mapI ] != -1 && 
+                      ! getObject( mMap[ mapI ] )->blocksWalking ) ) {
+                    
+                    int emptyX = clickDestX + nDX[n];
+                    int emptyY = clickDestY + nDY[n];
+
+                    // check if there's a path there
+                    int oldXD = ourLiveObject->xd;
+                    int oldYD = ourLiveObject->yd;
+                    
+                    // set this temporarily for pathfinding
+                    ourLiveObject->xd = emptyX;
+                    ourLiveObject->yd = emptyY;
+                    
+                    computePathToDest( ourLiveObject );
+                    
+                    if( ourLiveObject->pathToDest != NULL &&
+                        ourLiveObject->pathLength < closestDist ) {
+                        
+                        // can get there
+                        
+                        moveDestX = emptyX;
+                        moveDestY = emptyY;
+                        
+                        closestDist = ourLiveObject->pathLength;
+                        
+                        foundEmpty = true;
+                        }
+                    
+                    // restore our old dest
+                    ourLiveObject->xd = oldXD;
+                    ourLiveObject->yd = oldYD;    
+
+                    if( n == 0 && foundEmpty ) {
+                        // always prefer tile itself, if that's an option
+                        // based on logic above, even if further
+                        break;
+                        }
+                    }
+                
+                }
+            }
+        
+        if( oldPathExists ) {
+            // restore it
+            computePathToDest( ourLiveObject );
+            }
+
+        if( foundEmpty ) {
+            canExecute = true;
+            }
+        // always try to move as close as possible, even
+        // if we can't actually get close enough to execute action
+        moveTo( moveDestX, moveDestY );
+        }
+    return canExecute;
+    }
+
+
+char LivingLifePage::prepareForActionMessage( int clickDestX, int clickDestY ) {
+    LiveObject *ourLiveObject = getOurLiveObject();
+
+    nextActionEating = false;
+    nextActionDropping = false;
+
+    char canExecute = moveNearTo( clickDestX, clickDestY );
+    if( canExecute ) {
+        if( nextActionMessageToSend != NULL ) {
+            delete [] nextActionMessageToSend;
+            nextActionMessageToSend = NULL;
+            }
+
+        playerActionTargetX = clickDestX;
+        playerActionTargetY = clickDestY;
+
+        ourLiveObject->actionTargetX = clickDestX;
+        ourLiveObject->actionTargetY = clickDestY;
+
+        ourLiveObject->actionTargetTweakX = 0;
+        ourLiveObject->actionTargetTweakY = 0;
+        }
+
+    return canExecute;
+    }
+
+
+
+char hasSpecialBareHandTransition( int destID ) {
+    // check for case where both bare-hand transition
+    // AND pickup applies
+    if( getNumContainerSlots( destID ) == 0 &&
+        ! getObject( destID )->permanent ) {
+
+        TransRecord *bareHandTrans = getTrans( 0, destID );
+
+        if( bareHandTrans != NULL &&
+            bareHandTrans->newTarget != 0 ) {
+
+            // bare hand trans exists, and it's NOT just a
+            // direct "pickup" trans that should always be applied
+            // (from target to new actor)
+            // The bare hand trans leaves something on the ground
+            // meaning that it is transformational (removing
+            // a plate from a stack, tweaking something, etc.)
+
+            return true;
+            }
+        }
+
+        return false;
+    }
+
+
+
+char hasEmptyTileTransition( int holdingID, int floorDestID ) {
+    if( holdingID > 0 ) {
+        ObjectRecord *held = 
+            getObject( holdingID );
+
+        if( held->foodValue == 0 ) {
+
+            TransRecord *r = 
+                getTrans( holdingID,
+                          -1 );
+
+            if( r != NULL &&
+                r->newTarget != 0 ) {
+
+                // a use-on-ground transition exists!
+                return true;
+                }
+            }
+
+        if( floorDestID > 0 ) {
+            // check if use on floor exists
+            TransRecord *r = 
+                getTrans( holdingID, 
+                          floorDestID );
+
+            if( r != NULL ) {
+                // a use-on-floor transition exists!
+                return true;
+                }
+            }
+        }
+    return false;
+    }
+
+
+
+void LivingLifePage::useAt(int clickDestX, int clickDestY) {
+    LiveObject *ourLiveObject = getOurLiveObject();
+
+    nextActionEating = false;
+    nextActionDropping = false;
+
+    char canExecute = true;
+    if( //destID != 0 &&
+        ourLiveObject->holdingID > 0 &&
+        getObject( ourLiveObject->holdingID )->useDistance > 1// &&
+        //getTrans( ourLiveObject->holdingID, destID ) != NULL ) {
+        ) {
+        // check if we're close enough to use this from here 
+        
+        double d = sqrt( ( clickDestX - ourLiveObject->xd ) * 
+                         ( clickDestX - ourLiveObject->xd )
+                         +
+                         ( clickDestY - ourLiveObject->yd ) * 
+                         ( clickDestY - ourLiveObject->yd ) );
+
+
+        if( getObject( ourLiveObject->holdingID )->useDistance >= d) {
+            canExecute = true;
+            playerActionTargetNotAdjacent = true;
+            }
+        else {
+            canExecute = moveNearTo( clickDestX, clickDestY );
+            }
+        }
+    else {
+        canExecute = moveNearTo( clickDestX, clickDestY );
+        }
+    if( canExecute ) {
+        if( nextActionMessageToSend != NULL ) {
+            delete [] nextActionMessageToSend;
+            nextActionMessageToSend = NULL;
+            }
+
+        nextActionMessageToSend = 
+            autoSprintf( "USE %d %d#",
+                         sendX( clickDestX ), 
+                         sendY( clickDestY ) );
+
+        playerActionTargetX = clickDestX;
+        playerActionTargetY = clickDestY;
+
+        ourLiveObject->actionTargetX = clickDestX;
+        ourLiveObject->actionTargetY = clickDestY;
+
+        ourLiveObject->actionTargetTweakX = 0;
+        ourLiveObject->actionTargetTweakY = 0;
+        }
+    }
+
+
+void LivingLifePage::dropAt(int clickDestX, int clickDestY) {
+    if( prepareForActionMessage( clickDestX, clickDestY ) ) {
+        nextActionMessageToSend = 
+            autoSprintf( "DROP %d %d -1#",
+                         sendX( clickDestX ), 
+                         sendY( clickDestY ) );
+
+        nextActionDropping = true;
+        }
+    }
+
+
+void LivingLifePage::removeAt(int clickDestX, int clickDestY) {
+    if( prepareForActionMessage( clickDestX, clickDestY ) ) {
+        nextActionMessageToSend = 
+            autoSprintf( "REMV %d %d -1#",
+                         sendX( clickDestX ), 
+                         sendY( clickDestY ) );
+        }
+    }
+
+
+void LivingLifePage::pickupBabyAt( int clickDestX, int clickDestY ) {
+    if( prepareForActionMessage( clickDestX, clickDestY ) ) {
+        nextActionMessageToSend =
+            autoSprintf( "BABY %d %d#",
+                         sendX( clickDestX ),
+                         sendY( clickDestY ) );
+        }
+    }
+
+
+void LivingLifePage::useOnOtherAt( int clickDestX, int clickDestY ) {
+    if( prepareForActionMessage( clickDestX, clickDestY ) ) {
+        nextActionMessageToSend =
+            autoSprintf( "UBABY %d %d -1#",
+                         sendX( clickDestX ),
+                         sendY( clickDestY ) );
+        }
+    }
+
+
+void LivingLifePage::killAt( int clickDestX, int clickDestY ) {
+    if( prepareForActionMessage( clickDestX, clickDestY ) ) {
+        nextActionMessageToSend =
+            autoSprintf( "KILL %d %d#",
+                         sendX( clickDestX ),
+                         sendY( clickDestY ) );
+        }
+    }
+
+
 
 void LivingLifePage::pointerDown( float inX, float inY ) {
     lastMouseX = inX;
@@ -18846,7 +19455,6 @@ void LivingLifePage::pointerDown( float inX, float inY ) {
     int moveDestX = clickDestX;
     int moveDestY = clickDestY;
     
-    char mustMove = false;
 
 
     
@@ -19300,7 +19908,7 @@ void LivingLifePage::pointerDown( float inX, float inY ) {
         // a move to an empty spot where we're not already standing
         // can interrupt current move
         
-        mustMove = true;
+        moveTo( clickDestX, clickDestY );
         }
     else if( ( modClick && ourLiveObject->holdingID != 0 )
              || tryingToPickUpBaby
@@ -19311,155 +19919,8 @@ void LivingLifePage::pointerDown( float inX, float inY ) {
         // use/drop modifier
         // OR pick up action
             
+        char canExecute = moveNearTo( clickDestX, clickDestY );
         
-        char canExecute = false;
-        char sideAccess = false;
-        
-        if( destID > 0 && getObject( destID )->sideAccess ) {
-            sideAccess = true;
-            }
-        
-
-        // direct click on adjacent cells or self cell?
-        if( isGridAdjacent( clickDestX, clickDestY,
-                            ourLiveObject->xd, ourLiveObject->yd )
-            || 
-            ( clickDestX == ourLiveObject->xd && 
-              clickDestY == ourLiveObject->yd ) ) {
-            
-            canExecute = true;
-            
-            if( sideAccess &&
-                ( clickDestY > ourLiveObject->yd ||
-                  clickDestY < ourLiveObject->yd ) ) {
-                // trying to access side-access object from N or S
-                canExecute = false;
-                }
-            }
-
-
-        if( ! canExecute ) {
-            // need to move to empty adjacent first, if it exists
-            
-            // also consider spot itself in some cases
-            
-            int nDX[5] = { 0, -1, +1, 0, 0 };
-            int nDY[5] = { 0, 0, 0, -1, +1 };
-            
-            char foundEmpty = false;
-            
-            int closestDist = 9999999;
-
-            char oldPathExists = ( ourLiveObject->pathToDest != NULL );
-            
-            // don't consider dest spot itself generally
-            int nStart = 1;
-            
-            int nLimit = 5;
-            
-            if( sideAccess ) {
-                // don't consider N or S neighbors
-                nLimit = 3;
-                }
-            else if( destID > 0 &&
-                     ourLiveObject->holdingID == 0 && 
-                     getObject( destID )->permanent &&
-                     ! getObject( destID )->blocksWalking ) {
-                
-                TransRecord *handTrans = getTrans( 0, destID );
-                
-                if( handTrans == NULL ||
-                    ( handTrans->newActor != 0 &&
-                      getObject( handTrans->newActor )->foodValue > 0 &&
-                        handTrans->newTarget != 0 &&
-                      ! getObject( handTrans->newTarget )->blocksWalking ) ) {
-                    // walk to tile itself if target is permanent
-                    // and not blocking, and hand is empty
-                    // AND this will result in something still
-                    // on the ground (so it's not a transforming pick-up,
-                    // like pulling an onion).
-                    // and the new thing on the ground is not blocking
-                    // (so we're not closing a door)
-                    // and what you get in the hand is edible
-                    // (example:  picking berries from behind the bush)
-                    //
-                    // this is the main situation where you'd want to
-                    // click the same target and yourself
-                    // multiple times in a row, so having yourself
-                    // as close as possible to the target matters
-                    nStart = 0;
-                    }
-                }
-
-
-
-            for( int n=nStart; n<nLimit; n++ ) {
-                int x = mapX + nDX[n];
-                int y = mapY + nDY[n];
-
-                if( y >= 0 && y < mMapD &&
-                    x >= 0 && x < mMapD ) {
-                 
-                    
-                    int mapI = y * mMapD + x;
-                    
-                    if( mMap[ mapI ] == 0
-                        ||
-                        ( mMap[ mapI ] != -1 && 
-                          ! getObject( mMap[ mapI ] )->blocksWalking ) ) {
-                        
-                        int emptyX = clickDestX + nDX[n];
-                        int emptyY = clickDestY + nDY[n];
-
-                        // check if there's a path there
-                        int oldXD = ourLiveObject->xd;
-                        int oldYD = ourLiveObject->yd;
-                        
-                        // set this temporarily for pathfinding
-                        ourLiveObject->xd = emptyX;
-                        ourLiveObject->yd = emptyY;
-                        
-                        computePathToDest( ourLiveObject );
-                        
-                        if( ourLiveObject->pathToDest != NULL &&
-                            ourLiveObject->pathLength < closestDist ) {
-                            
-                            // can get there
-                            
-                            moveDestX = emptyX;
-                            moveDestY = emptyY;
-                            
-                            closestDist = ourLiveObject->pathLength;
-                            
-                            foundEmpty = true;
-                            }
-                        
-                        // restore our old dest
-                        ourLiveObject->xd = oldXD;
-                        ourLiveObject->yd = oldYD;    
-
-                        if( n == 0 && foundEmpty ) {
-                            // always prefer tile itself, if that's an option
-                            // based on logic above, even if further
-                            break;
-                            }
-                        }
-                    
-                    }
-                }
-            
-            if( oldPathExists ) {
-                // restore it
-                computePathToDest( ourLiveObject );
-                }
-
-            if( foundEmpty ) {
-                canExecute = true;
-                }
-            // always try to move as close as possible, even
-            // if we can't actually get close enough to execute action
-            mustMove = true;
-            }
         
 
         if( canExecute ) {
@@ -19506,45 +19967,8 @@ void LivingLifePage::pointerDown( float inX, float inY ) {
                     // check for other special case
                     // a use-on-ground transition or use-on-floor transition
 
-                    if( ourLiveObject->holdingID > 0 ) {
-                        
-                        ObjectRecord *held = 
-                            getObject( ourLiveObject->holdingID );
-                        
-                        char foundAlt = false;
-                        
-                        if( held->foodValue == 0 ) {
-                            
-                            TransRecord *r = 
-                                getTrans( ourLiveObject->holdingID,
-                                          -1 );
-                            
-                            if( r != NULL &&
-                                r->newTarget != 0 ) {
-                                
-                                // a use-on-ground transition exists!
-                                
-                                // override the drop action
-                                action = "USE";
-                                foundAlt = true;
-                                }
-                            }
-
-                        if( !foundAlt && floorDestID > 0 ) {
-                            // check if use on floor exists
-                            TransRecord *r = 
-                                getTrans( ourLiveObject->holdingID, 
-                                          floorDestID );
-                                
-                            if( r != NULL ) {
-                                // a use-on-floor transition exists!
-                                
-                                // override the drop action
-                                action = "USE";
-                                
-                                }
-                            }
-
+                    if( hasEmptyTileTransition( ourLiveObject->holdingID, floorDestID ) ) {
+                        action = "USE";
                         }
                     }
                 }
@@ -19666,222 +20090,6 @@ void LivingLifePage::pointerDown( float inX, float inY ) {
             delete [] extra;
             }
         }
-    
-
-
-    
-    if( mustMove ) {
-        
-        int oldXD = ourLiveObject->xd;
-        int oldYD = ourLiveObject->yd;
-        
-        ourLiveObject->xd = moveDestX;
-        ourLiveObject->yd = moveDestY;
-        ourLiveObject->destTruncated = false;
-
-        ourLiveObject->inMotion = true;
-
-
-        GridPos *oldPathToDest = NULL;
-        int oldPathLength = 0;
-        int oldCurrentPathStep = 0;
-        
-        if( ourLiveObject->pathToDest != NULL ) {
-            oldPathLength = ourLiveObject->pathLength;
-            oldPathToDest = new GridPos[ oldPathLength ];
-
-            memcpy( oldPathToDest, ourLiveObject->pathToDest,
-                    sizeof( GridPos ) * ourLiveObject->pathLength );
-            oldCurrentPathStep = ourLiveObject->currentPathStep;
-            }
-        
-
-        computePathToDest( ourLiveObject );
-
-        
-        if( ourLiveObject->pathToDest == NULL ) {
-            // adjust move to closest possible
-            ourLiveObject->xd = ourLiveObject->closestDestIfPathFailedX;
-            ourLiveObject->yd = ourLiveObject->closestDestIfPathFailedY;
-            ourLiveObject->destTruncated = false;
-            
-            if( ourLiveObject->xd == oldXD && ourLiveObject->yd == oldYD ) {
-                // completely blocked in, no path at all toward dest
-                
-                if( oldPathToDest != NULL ) {
-                    // restore it
-                    ourLiveObject->pathToDest = oldPathToDest;
-                    ourLiveObject->pathLength = oldPathLength;
-                    ourLiveObject->currentPathStep = oldCurrentPathStep;
-                    oldPathToDest = NULL;
-                    }
-                
-                    
-
-                // ignore click
-                
-                if( nextActionMessageToSend != NULL ) {
-                    delete [] nextActionMessageToSend;
-                    nextActionMessageToSend = NULL;
-                    }
-                ourLiveObject->inMotion = false;
-                return;
-                }
-
-            if( oldPathToDest != NULL ) {
-                delete [] oldPathToDest;
-                oldPathToDest = NULL;
-                }
-            
-
-            computePathToDest( ourLiveObject );
-            
-            if( ourLiveObject->pathToDest == NULL &&
-                ourLiveObject->useWaypoint ) {
-                // waypoint itself may be blocked
-                // try again with no waypoint at all
-                ourLiveObject->useWaypoint = false;
-                computePathToDest( ourLiveObject );
-                }
-
-            if( ourLiveObject->pathToDest == NULL ) {
-                // this happens when our curPos is slightly off of xd,yd
-                // but not a full cell away
-
-                // make a fake path
-                doublePair dest = { (double) ourLiveObject->xd,
-                                    (double) ourLiveObject->yd };
-                
-                doublePair dir = normalize( sub( dest, 
-                                                 ourLiveObject->currentPos ) );
-
-                // fake start, one grid step away
-                doublePair fakeStart = dest;
-
-                if( fabs( dir.x ) > fabs( dir.y ) ) {
-                    
-                    if( dir.x < 0 ) {
-                        fakeStart.x += 1;
-                        }
-                    else {
-                        fakeStart.x -= 1;
-                        }
-                    }
-                else {
-                    if( dir.y < 0 ) {
-                        fakeStart.y += 1;
-                        }
-                    else {
-                        fakeStart.y -= 1;
-                        }
-                    
-                    }
-                
-                
-                ourLiveObject->pathToDest = new GridPos[2];
-                
-                ourLiveObject->pathToDest[0].x = (int)fakeStart.x;
-                ourLiveObject->pathToDest[0].y = (int)fakeStart.y;
-                
-                ourLiveObject->pathToDest[1].x = ourLiveObject->xd;
-                ourLiveObject->pathToDest[1].y = ourLiveObject->yd;
-                
-                ourLiveObject->pathLength = 2;
-                ourLiveObject->currentPathStep = 0;
-                ourLiveObject->numFramesOnCurrentStep = 0;
-                ourLiveObject->onFinalPathStep = false;
-                
-                ourLiveObject->currentMoveDirection =
-                    normalize( 
-                        sub( gridToDouble( ourLiveObject->pathToDest[1] ), 
-                             gridToDouble( ourLiveObject->pathToDest[0] ) ) );
-                }
-
-            if( ourLiveObject->xd == oldXD 
-                &&
-                ourLiveObject->yd == oldYD ) {
-                
-                // truncated path is where we're already going
-                // don't send new move message
-                return;
-                }
-
-
-            moveDestX = ourLiveObject->xd;
-            moveDestY = ourLiveObject->yd;
-            
-            if( nextActionMessageToSend != NULL ) {
-                // abort the action, because we can't reach the spot we
-                // want to reach
-                delete [] nextActionMessageToSend;
-                nextActionMessageToSend = NULL;
-                }
-            
-            }
-        
-        
-        if( oldPathToDest != NULL ) {
-            delete [] oldPathToDest;
-            oldPathToDest = NULL;
-            }
-            
-
-
-        // send move right away
-        //Thread::staticSleep( 2000 );
-        SimpleVector<char> moveMessageBuffer;
-        
-        moveMessageBuffer.appendElementString( "MOVE" );
-        ourLiveObject->lastMoveSequenceNumber ++;
-        
-        // start is absolute
-        char *startString = 
-            autoSprintf( " %d %d @%d", 
-                         sendX( ourLiveObject->pathToDest[0].x ),
-                         sendY( ourLiveObject->pathToDest[0].y ),
-                         ourLiveObject->lastMoveSequenceNumber );
-        moveMessageBuffer.appendElementString( startString );
-        delete [] startString;
-        
-        for( int i=1; i<ourLiveObject->pathLength; i++ ) {
-            // rest are relative to start
-            char *stepString = autoSprintf( " %d %d", 
-                                         ourLiveObject->pathToDest[i].x
-                                            - ourLiveObject->pathToDest[0].x,
-                                         ourLiveObject->pathToDest[i].y
-                                            - ourLiveObject->pathToDest[0].y );
-            
-            moveMessageBuffer.appendElementString( stepString );
-            delete [] stepString;
-            }
-        moveMessageBuffer.appendElementString( "#" );
-        
-
-        char *message = moveMessageBuffer.getElementString();
-
-        sendToServerSocket( message );
-
-
-        delete [] message;
-
-        // start moving before we hear back from server
-
-
-
-        double floorSpeedMod = computePathSpeedMod( ourLiveObject,
-                                                    ourLiveObject->pathLength );
-        
-
-        ourLiveObject->moveTotalTime = 
-            measurePathLength( ourLiveObject, ourLiveObject->pathLength ) / 
-            ( ourLiveObject->lastSpeed * floorSpeedMod );
-
-        ourLiveObject->moveEtaTime = game_getCurrentTime() +
-            ourLiveObject->moveTotalTime;
-
-            
-        updateMoveSpeed( ourLiveObject );
-        }    
     }
 
 
diff --git a/gameSource/LivingLifePage.h b/gameSource/LivingLifePage.h
index 988c78bc..8d3965a7 100644
--- a/gameSource/LivingLifePage.h
+++ b/gameSource/LivingLifePage.h
@@ -352,6 +352,16 @@ typedef struct PointerHitRecord {
 
 
 
+typedef struct CellHitRecord {
+        int cellX;
+        int cellY;
+        int destID;
+        int floorDestID;
+        int destNumContained;
+    } CellHitRecord;
+
+
+
 typedef struct OldArrow {
         int i;
         float heat;
@@ -814,6 +824,16 @@ class LivingLifePage : public GamePage, public ActionListener {
         // forces next pointerDown call to avoid everything but ground clicks
         char mForceGroundClick;
         
+        void checkForCellHit( CellHitRecord& inRecord );
+        void moveTo( int moveDestX, int moveDestY );
+        char moveNearTo( int clickDestX, int clickDestY );
+        char prepareForActionMessage( int clickDestX, int clickDestY );
+        void useAt( int clickDestX, int clickDestY );
+        void dropAt( int clickDestX, int clickDestY );
+        void removeAt( int clickDestX, int clickDestY );
+        void pickupBabyAt( int clickDestX, int clickDestY );
+        void useOnOtherAt( int clickDestX, int clickDestY );
+        void killAt( int clickDestX, int clickDestY );
 
 
         LiveObject *getOurLiveObject();
