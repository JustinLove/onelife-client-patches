diff --git a/gameSource/LivingLifePage.cpp b/gameSource/LivingLifePage.cpp
index 05f67123..fbb78a83 100644
--- a/gameSource/LivingLifePage.cpp
+++ b/gameSource/LivingLifePage.cpp
@@ -1376,6 +1376,8 @@ static LiveObject *getGameObject( int inID ) {
     }
 
 
+SimpleVector<char*> knownNames;
+
 
 extern char autoAdjustFramerate;
 extern int baseFramesPerSecond;
@@ -2356,6 +2358,7 @@ void LivingLifePage::clearLiveObjects() {
         }
     
     gameObjects.deleteAll();
+    knownNames.deallocateStringElements();
     }
 
 
@@ -15095,6 +15098,7 @@ void LivingLifePage::step() {
                                 char *nameStart = &( firstSpace[1] );
                                 
                                 existing->name = stringDuplicate( nameStart );
+                                knownNames.push_back(stringDuplicate( nameStart ));
                                 }
                             
                             break;
@@ -19381,6 +19385,10 @@ void LivingLifePage::keyDown( unsigned char inASCII ) {
                 }
             break;
         case 9: // tab
+            if( mSayField.isFocused() ) {
+                nameCompletion();
+                }
+            else
             if( mCurrentHintObjectID != 0 ) {
                 
                 int num = getNumHints( mCurrentHintObjectID );
@@ -19757,7 +19765,175 @@ void LivingLifePage::keyUp( unsigned char inASCII ) {
     }
 
         
+void LivingLifePage::fadeErasedCharacters() {
+    if( mCurrentNoteChars.size() > 0 ) {
+        // fade older erased chars 
+
+        for( int i=0; i<mErasedNoteCharFades.size(); i++ ) {
+            if( mErasedNoteCharFades.getElementDirect( i ) > 0.5 ) {
+                *( mErasedNoteCharFades.getElement( i ) ) -= 0.2;
+                }
+            else {
+                *( mErasedNoteCharFades.getElement( i ) ) -= 0.1;
+                }
+
+            if( mErasedNoteCharFades.getElementDirect( i ) <= 0 ) {
+                mErasedNoteCharFades.deleteElement( i );
+                mErasedNoteChars.deleteElement( i );
+                mErasedNoteCharOffsets.deleteElement( i );
+                i--;
+                }
+            }
+        }
+
+    // first, remove exact duplicates from erased
+    for( int i=0; i<mCurrentNoteChars.size(); i++ ) {
+        char c = mCurrentNoteChars.getElementDirect( i );
+        doublePair pos = 
+            mCurrentNoteCharOffsets.getElementDirect( i );
+
+        for( int j=0; j<mErasedNoteChars.size(); j++ ) {
+            if( mErasedNoteChars.getElementDirect(j) == c 
+                &&
+                equal( mErasedNoteCharOffsets.getElementDirect(j),
+                       pos ) ) {
+
+                mErasedNoteChars.deleteElement( j );
+                mErasedNoteCharOffsets.deleteElement( j );
+                mErasedNoteCharFades.deleteElement( j );
+                j--;
+                }
+            }
+        }
+
+
+    for( int i=0; i<mCurrentNoteChars.size(); i++ ) {
+        mErasedNoteChars.push_back( 
+            mCurrentNoteChars.getElementDirect( i ) );
+
+        mErasedNoteCharOffsets.push_back(
+            mCurrentNoteCharOffsets.getElementDirect( i ) );
+
+        mErasedNoteCharFades.push_back( 1.0f );
+        }
+    }
+
+
+char originalCompletionText[256] = {0};
+unsigned int originalCompletionLength = 0;
+
+
+const char* nameDetection(const char * const inString ) {
+    unsigned int textLength = strlen(inString);
+    const char* nameText = NULL;
+
+    if( textLength > 6 && strncmp( inString, "CURSE ", 6 ) == 0 ) {
+        return inString + 6;
+        }
+    else {
+        nameText = strrchr( inString, ' ' );
+        if( nameText == NULL ) {
+            return inString;
+            }
+        else {
+            return nameText + 1;
+            }
+        }
+    }
+
 
+int trailingNameMatch( const char * const inString ) {
+    unsigned int textLength = strlen(inString);
+
+    if( textLength == 0 ) return -1;
+
+    for( int i=knownNames.size()-1; i>=0; i-- ) {
+        char * name = knownNames.getElementDirect( i );
+        if ( name == NULL ) continue;
+        unsigned int nameLength = strlen(name);
+        if( textLength >= nameLength && strncmp( inString + (textLength - nameLength), knownNames.getElementDirect( i ), nameLength )
+            == 0 ) {
+            return i;
+            }
+        }
+
+    return -1;
+    }
+
+
+int nameMatching(const char * const nameText, int startNameIndex) {
+    unsigned int nameLength = strlen(nameText);
+
+    if( nameLength == 0 ) return -1;
+
+    for( int i=startNameIndex-1; i>=0; i-- ) {
+        char * name = knownNames.getElementDirect( i );
+        if ( name == NULL ) continue;
+        if( strncmp( nameText, name, nameLength )
+            == 0 ) {
+            return i;
+            }
+        }
+
+    for( int i=knownNames.size()-1; i>=startNameIndex+1; i-- ) {
+        char * name = knownNames.getElementDirect( i );
+        if ( name == NULL ) continue;
+        if( strncmp( nameText, name, nameLength )
+            == 0 ) {
+            return i;
+            }
+        }
+
+        return -1;
+    }
+
+
+void LivingLifePage::nameCompletion() {
+    if( ! mSayField.isFocused() ) return;
+
+    char *curText = mSayField.getText();
+
+    int curNameIndex = trailingNameMatch( curText );
+
+    // no exact match, has not run yet capture partial name for matching
+    if( curNameIndex == -1 ) {
+        strncpy(originalCompletionText, curText, 255);
+        originalCompletionLength = strlen(originalCompletionText);
+        }
+
+    delete [] curText;
+
+    // exact match, but prefix has changed so not a continuation
+    if ( strncmp( curText, originalCompletionText, originalCompletionLength ) != 0 ) return;
+
+    // name match, but no partial name to work with
+    if ( originalCompletionLength == 0 ) return;
+
+    // some text to try and find partial name in, try next name
+
+    const char* nameText = nameDetection( originalCompletionText );
+
+    int newIndex = nameMatching( nameText, curNameIndex );
+
+    if( newIndex < 0 || newIndex >= knownNames.size() ) return;
+
+    fadeErasedCharacters();
+
+    char say[256];
+    const char* name = knownNames.getElementDirect( newIndex );
+    if ( name == NULL ) return;
+    unsigned int prefixLength = nameText - originalCompletionText;
+    if ( prefixLength > 255 ) return;
+    strncpy( say, originalCompletionText, prefixLength );
+    unsigned int maxLength = mSayField.getMaxLength();
+    if (maxLength > 255) {
+        maxLength = 255;
+        }
+    if (maxLength < prefixLength) return;
+    strncpy( say + prefixLength, name, maxLength-prefixLength );
+    say[maxLength] = 0;
+    mSayField.setText( say );
+    }
 
 
 ExtraMapObject LivingLifePage::copyFromMap( int inMapI ) {
diff --git a/gameSource/LivingLifePage.h b/gameSource/LivingLifePage.h
index 4125202a..f2e00bc6 100644
--- a/gameSource/LivingLifePage.h
+++ b/gameSource/LivingLifePage.h
@@ -433,6 +433,8 @@ class LivingLifePage : public GamePage {
         
         virtual void keyUp( unsigned char inASCII );
 
+        void fadeErasedCharacters();
+        void nameCompletion();
         
         // handles error detection, total byte counting, etc.
         void sendToServerSocket( char *inMessage );
