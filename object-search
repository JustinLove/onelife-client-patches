diff --git a/gameSource/LivingLifePage.cpp b/gameSource/LivingLifePage.cpp
index 980432da..a93342e4 100644
--- a/gameSource/LivingLifePage.cpp
+++ b/gameSource/LivingLifePage.cpp
@@ -484,6 +484,7 @@ typedef struct {
 static FloatColor gold = { 255.0/255, 227.0/255, 50.0/255, 1 };
 static FloatColor blood = { 244.0/255, 16.0/255, 8.0/255, 1 };
 static FloatColor indigo = { 122.0/255, 126.0/255, 244.0/255, 1 };
+static FloatColor hintBlue = { 20.0/255, 94.0/255, 196.0/255, 1 };
 static FloatColor pink = { 250.0/255, 144.0/255, 146.0/255, 1 };
 static FloatColor stone = { 128.0/255, 125.0/255, 149.0/255, 1 };
 static FloatColor sepia = { 203.0/255, 165.0/255, 114.0/255, 1 };
@@ -752,6 +753,7 @@ void LivingLifePage::addLocationSlip( int inX, int inY ) {
     p.temporary = false;
     p.labeled = true;
     p.tempPerson = false;
+    p.search = false;
     p.temporaryExpireETA = 0;
     p.creationTime = game_getCurrentTime();
     p.pointerBounce = 0;
@@ -828,6 +830,7 @@ void LivingLifePage::addTempLocationSlip( int inX, int inY,
     p.ancient = false;
     p.temporary = true;
     p.labeled = false;
+    p.search = false;
     // no expiration for now
     // until we drop the map
     p.temporaryExpireETA = 0;
@@ -884,6 +887,36 @@ void LivingLifePage::addTempLocationSlip( int inX, int inY,
 
 
 
+void LivingLifePage::addSearchLocationSlip( int inX, int inY ) {
+    for( int i=0; i<mLocationSlips.size(); i++ ) {
+        LocationSlip *p = mLocationSlips.getElement( i );
+
+        if( p->search ) {
+            updateLocationSlip( p, inX, inY );
+            p->temporaryExpireETA = game_getCurrentTime() + 60;
+            return;
+            }
+        }
+
+    GridPos newPos = { inX, inY };
+    LocationSlip p;
+    p.pos = newPos;
+    p.ancient = false;
+    p.temporary = true;
+    p.labeled = false;
+    p.tempPerson = false;
+    p.search = true;
+    p.temporaryExpireETA = game_getCurrentTime() + 60;
+    p.posOffset = p.targetOffset = p.hideOffset = {LOCATION_SLIP_MAP_X, LOCATION_SLIP_BOTTOM_Y};
+    p.creationTime = game_getCurrentTime();
+    p.slipColor = hintBlue;
+    p.personID = -1;
+    p.tempPersonKey = NULL;
+    mLocationSlips.push_front( p );
+    }
+
+
+
 static void updatePersonHomeLocation( int inPersonID, int inX, int inY ) {
     for( int i=0; i<homePosStack.size(); i++ ) {
         HomePos *p = homePosStack.getElement( i );
@@ -963,6 +996,7 @@ void LivingLifePage::addAncientLocationSlip( int inX, int inY, int monumentID )
     p.temporary = false;
     p.labeled = false;
     p.tempPerson = false;
+    p.search = false;
     p.posOffset = p.targetOffset = p.hideOffset = {LOCATION_SLIP_RIGHT_X, LOCATION_SLIP_RIGHT_Y};
     p.pointerBounce = 0;
     p.pointerFade = 0;
@@ -991,6 +1025,7 @@ void LivingLifePage::addHomelandLocationSlip( int inX, int inY, const char* inFa
     p.tempPerson = false;
     p.pointerBounce = 0;
     p.pointerFade = 0;
+    p.search = false;
     p.posOffset = p.targetOffset = p.hideOffset = {LOCATION_SLIP_RIGHT_X, LOCATION_SLIP_RIGHT_Y};
     if( inFamilyName ) {
         p.creationTime = game_getCurrentTime();
@@ -3198,6 +3233,56 @@ void LivingLifePage::clearMap() {
 
 
 
+void LivingLifePage::findInMap() {
+    doublePair nearestPos;
+    double dist = mMapD*mMapD;
+    char found = false;
+    doublePair center = mult(lastScreenViewCenter, 1.0/CELL_D);
+    for( int i=0; i<mMapD *mMapD; i++ ) {
+        // -1 represents unknown
+        // 0 represents known empty
+        int oID = mMap[i];
+        if( oID < 1 ) continue;
+        oID = getObjectParent( oID );
+        int index = mSoughtObjects.getElementIndex( oID );
+        if( index < 0 ) {
+            int numCont = mMapContainedStacks[i].size();
+
+            for( int j=0; j<numCont && index <= 0; j++ ) {
+                oID = mMapContainedStacks[i].getElementDirect( j );
+                index = mSoughtObjects.getElementIndex( oID );
+
+                SimpleVector<int> *subVec =
+                    mMapSubContainedStacks[i].getElement( j );
+
+                int numSub = subVec->size();
+                for( int s=0; s<numSub && index <= 0; s++ ) {
+                    oID = subVec->getElementDirect( s );
+                    index = mSoughtObjects.getElementIndex( oID );
+                    }
+                }
+            }
+        if( index >= 0 ) {
+            int wx = i % mMapD + mMapOffsetX - mMapD / 2;
+            int wy = i / mMapD + mMapOffsetY - mMapD / 2;
+            doublePair pos = {(double)wx, (double)wy};
+            double d = distance( pos, center );
+            //printf( "sought %d: %d %d,%d (%f)\n", oID, i, wx, wy, d );
+            if( d < dist ) {
+                found = true;
+                nearestPos = pos;
+                dist = d;
+                //printf( "nearest %d: %d %d,%d (%f)\n", oID, i, wx, wy, d );
+                }
+            }
+        }
+    if( found ) {
+        addSearchLocationSlip( lrint( nearestPos.x ), lrint( nearestPos.y ) );
+        }
+    }
+
+
+
 LivingLifePage::LivingLifePage() 
         : mServerSocket( -1 ), 
           mForceRunTutorial( false ),
@@ -12997,6 +13082,28 @@ int LivingLifePage::getNumHints( int inObjectID ) {
         }
 
 
+    if( mLastHintFilterString != NULL ) {
+        mSoughtObjects.deleteAll();
+        int remaining;
+        int hits;
+        ObjectRecord** hitObjects = searchObjects(
+            mLastHintFilterString,
+            0, // don't filter out what we're holding
+            200,
+            &hits, &remaining );
+
+        if( hits > 0 ) {
+            for( int i=0; i<hits; i++ ) {
+                int oID = hitObjects[i]->id;
+                mSoughtObjects.push_back(oID);
+                //printf("hit %d\n", oID);
+                }
+            delete [] hitObjects;
+            findInMap();
+            }
+        }
+
+
     int numTrans = filteredTrans.size();
 
     int numRelevant = numTrans;
@@ -16635,6 +16742,8 @@ void LivingLifePage::step() {
                 
                 tokens->deallocateStringElements();
                 delete tokens;
+
+                findInMap();
                 
                 if( !( mFirstServerMessagesReceived & 1 ) ) {
                     // first map chunk just recieved
@@ -17527,6 +17636,7 @@ void LivingLifePage::step() {
                 }
             
             delete [] lines;
+            findInMap();
             }
         else if( type == PLAYER_UPDATE ) {
             
@@ -17860,6 +17970,8 @@ void LivingLifePage::step() {
                         existing->id == ourID ) {
                         // got a PU for self
 
+                        findInMap();
+
                         if( existing->holdingID != o.holdingID ) {
                             // holding change
                             // if we have a temp home arrow
@@ -23416,6 +23528,7 @@ void LivingLifePage::makeActive( char inFresh ) {
         }
 
     mOldHintArrows.deleteAll();
+    mSoughtObjects.deleteAll();
 
     mGlobalMessageShowing = false;
     mGlobalMessageStartTime = 0;
diff --git a/gameSource/LivingLifePage.h b/gameSource/LivingLifePage.h
index e65452b9..e1e9ac98 100644
--- a/gameSource/LivingLifePage.h
+++ b/gameSource/LivingLifePage.h
@@ -485,6 +485,7 @@ typedef struct LocationSlip {
         char temporary;
         char labeled;
         char tempPerson;
+        char search;
         int personID;
         const char *tempPersonKey;
         // 0 if not set
@@ -545,6 +546,7 @@ class LivingLifePage : public GamePage, public ActionListener {
         ~LivingLifePage();
         
         void clearMap();
+        void findInMap();
         
         // enabled tutorail next time a connection loads
         void runTutorial();
@@ -837,6 +839,9 @@ class LivingLifePage : public GamePage, public ActionListener {
         SimpleVector<OldHintArrow> mOldHintArrows;
 
 
+        SimpleVector<int> mSoughtObjects;
+
+
         SimpleVector<TransRecord *> mLastHintSortedList;
         int mLastHintSortedSourceID;
         char *mLastHintFilterString;
@@ -1138,6 +1143,7 @@ class LivingLifePage : public GamePage, public ActionListener {
         void setLocationSlipExpiration( int seconds );
         void addLocationSlip( int inX, int inY );
         void addTempLocationSlip( int inX, int inY, char inPerson, int inPersonID, const char* inPersonKey, int inAge );
+        void addSearchLocationSlip( int inX, int inY );
         void updateLocationSlip( LocationSlip* locationSlip, int inX, int inY );
         void updatePersonLocationSlip( int inPersonID, int inX, int inY );
         void addAncientLocationSlip( int inX, int inY, int monumentID );
